[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/MiniSearch.js",
    "content": "import SearchableMap from './SearchableMap/SearchableMap.js'\n\nconst OR = 'or'\nconst AND = 'and'\n\n/**\n* MiniSearch is the main entrypoint class, and represents a full-text search\n* engine.\n*\n* @example\n* const documents = [\n*   {\n*     id: 1,\n*     title: 'Moby Dick',\n*     text: 'Call me Ishmael. Some years ago...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 2,\n*     title: 'Zen and the Art of Motorcycle Maintenance',\n*     text: 'I can see by my watch...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 3,\n*     title: 'Neuromancer',\n*     text: 'The sky above the port was...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 4,\n*     title: 'Zen and the Art of Archery',\n*     text: 'At first sight it must seem...',\n*     category: 'non-fiction'\n*   },\n*   // ...and more\n* ]\n*\n* // Create a search engine that indexes the 'title' and 'text' fields for\n* // full-text search. Search results will include 'title' and 'category' (plus the\n* // id field, that is always stored and returned)\n* const miniSearch = MiniSearch.new({\n*   fields: ['title', 'text'],\n*   storeFields: ['title', 'category']\n* })\n*\n* // Add documents to the index\n* miniSearch.addAll(documents)\n*\n* // Search for documents:\n* let results = miniSearch.search('zen art motorcycle')\n* // => [\n*   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n*   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n* ]\n* */\nclass MiniSearch {\n  /**\n  * @param {Object} options - Configuration options\n  * @param {Array<string>} options.fields - Fields to be indexed. Required.\n  * @param {string} [options.idField='id'] - ID field, uniquely identifying a document\n  * @param {Array<string>} [options.storeFields] - Fields to store, so that search results would include them. By default none, so resuts would only contain the id field.\n  * @param {function(document: Object, fieldName: string): string} [options.extractField] - Function used to get the value of a field in a document\n  * @param {function(text: string, [fieldName]: string): Array<string>} [options.tokenize] - Function used to split a field into individual terms\n  * @param {function(term: string, [fieldName]: string): string} [options.processTerm] - Function used to process a term before indexing it or searching\n  * @param {Object} [options.searchOptions] - Default search options (see the `search` method for details)\n  *\n  * @example\n  * // Create a search engine that indexes the 'title' and 'text' fields of your\n  * // documents:\n  * const miniSearch = MiniSearch.new({ fields: ['title', 'text'] })\n  *\n  * @example\n  * // Your documents are assumed to include a unique 'id' field, but if you want\n  * // to use a different field for document identification, you can set the\n  * // 'idField' option:\n  * const miniSearch = MiniSearch.new({ idField: 'key', fields: ['title', 'text'] })\n  *\n  * @example\n  * // The full set of options (here with their default value) is:\n  * const miniSearch = MiniSearch.new({\n  *   // idField: field that uniquely identifies a document\n  *   idField: 'id',\n  *\n  *   // extractField: function used to get the value of a field in a document.\n  *   // By default, it assumes the document is a flat object with field names as\n  *   // property keys and field values as string property values, but custom logic\n  *   // can be implemented by setting this option to a custom extractor function.\n  *   extractField: (document, fieldName) => document[fieldName],\n  *\n  *   // tokenize: function used to split fields into individual terms. By\n  *   // default, it is also used to tokenize search queries, unless a specific\n  *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n  *   // the field name is passed as the second argument.\n  *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  *\n  *   // processTerm: function used to process each tokenized term before\n  *   // indexing. It can be used for stemming and normalization. Return a falsy\n  *   // value in order to discard a term. By default, it is also used to process\n  *   // search queries, unless a specific `processTerm` option is supplied as a\n  *   // search option. When processing a term from a indexed field, the field\n  *   // name is passed as the second argument.\n  *   processTerm: (term, _fieldName) => term.toLowerCase(),\n  *\n  *   // searchOptions: default search options, see the `search` method for\n  *   // details\n  *   searchOptions: undefined,\n  *\n  *   // fields: document fields to be indexed. Mandatory, but not set by default\n  *   fields: undefined\n  *\n  *   // storeFields: document fields to be stored and returned as part of the\n  *   // search results.\n  *   storeFields: []\n  * })\n  */\n  constructor (options = {}) {\n    /** @private */\n    this._options = { ...defaultOptions, ...options }\n\n    this._options.searchOptions = { ...defaultSearchOptions, ...(this._options.searchOptions || {}) }\n    const { fields } = this._options\n\n    if (fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    /** @private */\n    this._index = new SearchableMap()\n\n    /** @private */\n    this._documentCount = 0\n\n    /** @private */\n    this._documentIds = {}\n\n    /** @private */\n    this._fieldIds = {}\n\n    /** @private */\n    this._fieldLength = {}\n\n    /** @private */\n    this._averageFieldLength = {}\n\n    /** @private */\n    this._nextId = 0\n\n    /** @private */\n    this._storedFields = {}\n\n    addFields(this, fields)\n  }\n\n  /**\n  * Adds a document to the index\n  *\n  * @param {Object} document - the document to be indexed\n  */\n  add (document) {\n    const { extractField, tokenize, processTerm, fields, idField } = this._options\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n    const shortDocumentId = addDocumentId(this, document[idField])\n    saveStoredFields(this, shortDocumentId, document)\n\n    fields.forEach(field => {\n      const tokens = tokenize(extractField(document, field) || '', field)\n      addFieldLength(this, shortDocumentId, this._fieldIds[field], this.documentCount - 1, tokens.length)\n      tokens.forEach(term => {\n        const processedTerm = processTerm(term, field)\n        if (isTruthy(processedTerm)) {\n          addTerm(this, this._fieldIds[field], shortDocumentId, processedTerm)\n        }\n      })\n    })\n  }\n\n  /**\n  * Adds all the given documents to the index\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  */\n  addAll (documents) {\n    documents.forEach(document => this.add(document))\n  }\n\n  /**\n  * Adds all the given documents to the index asynchronously.\n  *\n  * Returns a promise that resolves to undefined when the indexing is done. This\n  * method is useful when index many documents, to avoid blocking the main\n  * thread. The indexing is performed asynchronously and in chunks.\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  * @param {Object} [options] - Configuration options\n  * @param {number} [options.chunkSize] - Size of the document chunks indexed, 10 by default\n  * @return {Promise} A promise resolving to `null` when the indexing is done\n  */\n  addAllAsync (documents, options = {}) {\n    const { chunkSize = 10 } = options\n    const acc = { chunk: [], promise: Promise.resolve(null) }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return { chunk: [], promise: promise.then(() => this.addAll(chunk)) }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n  * Removes the given document from the index.\n  *\n  * The document to delete must NOT have changed between indexing and deletion,\n  * otherwise the index will be corrupted. Therefore, when reindexing a document\n  * after a change, the correct order of operations is:\n  *\n  *   1. remove old version\n  *   2. apply changes\n  *   3. index new version\n  *\n  * @param {Object} document - the document to be indexed\n  */\n  remove (document) {\n    const { tokenize, processTerm, fields, idField } = this._options\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n    const [shortDocumentId] = Object.entries(this._documentIds)\n      .find(([_, longId]) => document[idField] === longId) || []\n    if (shortDocumentId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${document[idField]}: it is not in the index`)\n    }\n    fields.filter(field => document[field] != null).forEach(field => {\n      tokenize(document[field]).forEach(term => {\n        const processedTerm = processTerm(term)\n        if (isTruthy(processedTerm)) {\n          removeTerm(this, this._fieldIds[field], shortDocumentId, processTerm(term))\n        }\n      })\n    })\n    delete this._storedFields[shortDocumentId]\n    delete this._documentIds[shortDocumentId]\n    this._documentCount -= 1\n  }\n\n  /**\n  * Search for documents matching the given search query.\n  *\n  * The result is a list of scored document IDs matching the query, sorted by\n  * descending score, and each including data about which terms were matched and\n  * in which fields.\n  *\n  * @param {string} queryString - Query string to search for\n  * @param {Object} [options] - Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n  * @param {Array<string>} [options.fields] - Fields to search in. If omitted, all fields are searched\n  * @param {Object<string, number>} [options.boost] - Key-value object of boosting values for fields\n  * @param {boolean|function(term: string, i: number, terms: Array<string>): boolean} [options.prefix=false] - Whether to perform prefix search. Value can be a boolean, or a function computing the boolean from each tokenized and processed query term. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {number|function(term: string, i: number, terms: Array<string>): boolean|number} [options.fuzzy=false] - If set to a number greater than or equal 1, it performs fuzzy search within a maximum edit distance equal to that value. If set to a number less than 1, it performs fuzzy search with a maximum edit distance equal to the term length times the value, rouded at the nearest integer. If set to a function, it calls the function for each tokenized and processed query term and expects a numeric value indicating the maximum edit distance, or a falsy falue if fuzzy search should not be performed. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {string} [options.combineWith='OR'] - How to combine term queries (it can be 'OR' or 'AND')\n  * @param {function(query: string): Array<string>} [options.tokenize] - Function used to tokenize the search query. It defaults to the same tokenizer used for indexing.\n  * @param {function(term: string): string|null|undefined|false} [options.processTerm] - Function used to process each search term. Return a falsy value to discard a term. Defaults to the same function used to process terms upon indexing.\n  * @param {function(result: Object): boolean} [options.filter] - Function used to filter search results, for example on the basis of stored fields\n  * @return {Array<{ id: any, score: number, match: Object }>} A sorted array of scored document IDs matching the search\n  *\n  * @example\n  * // Search for \"zen art motorcycle\" with default options: terms have to match\n  * // exactly, and individual terms are joined with OR\n  * miniSearch.search('zen art motorcycle')\n  * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n  *\n  * @example\n  * // Search only in the 'title' field\n  * miniSearch.search('zen', { fields: ['title'] })\n  *\n  * @example\n  * // Boost a field\n  * miniSearch.search('zen', { boost: { title: 2 } })\n  *\n  * @example\n  * // Search for \"moto\" with prefix search (it will match documents\n  * // containing terms that start with \"moto\" or \"neuro\")\n  * miniSearch.search('moto neuro', { prefix: true })\n  *\n  * @example\n  * // Search for \"ismael\" with fuzzy search (it will match documents containing\n  * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n  * // (rounded to nearest integer)\n  * miniSearch.search('ismael', { fuzzy: 0.2 })\n  *\n  * @example\n  * // Mix of exact match, prefix search, and fuzzy search\n  * miniSearch.search('ismael mob', {\n  *  prefix: true,\n  *  fuzzy: 0.2\n  * })\n  *\n  * @example\n  * // Perform fuzzy and prefix search depending on the search term. Here\n  * // performing prefix and fuzzy search only on terms longer than 3 characters\n  * miniSearch.search('ismael mob', {\n  *  prefix: term => term.length > 3\n  *  fuzzy: term => term.length > 3 ? 0.2 : null\n  * })\n  *\n  * @example\n  * // Combine search terms with AND (to match only documents that contain both\n  * // \"motorcycle\" and \"art\")\n  * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n  *\n  * @example\n  * // Filter only results in the 'fiction' category (assuming that 'category'\n  * // is a stored field)\n  * miniSearch.search('motorcycle art', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  */\n  search (queryString, options = {}) {\n    const { tokenize, processTerm, searchOptions } = this._options\n    options = { tokenize, processTerm, ...searchOptions, ...options }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const queries = searchTokenize(queryString)\n      .map((term) => searchProcessTerm(term))\n      .filter(isTruthy)\n      .map(termToQuery(options))\n    let results = queries.map(query => this.executeQuery(query, options))\n    results = this.combineResults(results, options.combineWith)\n\n    results = Object.entries(results)\n      .map(([docId, { score, match, terms }]) => ({\n        ...(this._storedFields[docId] || {}),\n        id: this._documentIds[docId],\n        terms: uniq(terms),\n        score,\n        match\n      }))\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n\n    if (typeof options.filter === 'function') {\n      results = results.filter(options.filter)\n    }\n\n    return results\n  }\n\n  /**\n  * Provide suggestions for the given search query\n  *\n  * The result is a list of suggested modified search queries, derived from the\n  * given search query, each with a relevance score, sorted by descending score.\n  *\n  * @param {string} queryString - Query string to be expanded into suggestions\n  * @param {Object} [options] - Search options. The supported options and default values are the same as for the `search` method, except that by default prefix search is performed on the last term in the query.\n  * @return {Array<{ suggestion: string, score: number }>} A sorted array of suggestions sorted by relevance score.\n  *\n  * @example\n  * // Get suggestions for 'neuro':\n  * miniSearch.autoSuggest('neuro')\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar':\n  * miniSearch.autoSuggest('zen ar')\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  *\n  * @example\n  * // Correct spelling mistakes using fuzzy search:\n  * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar', but only within the 'fiction' category\n  * // (assuming that 'category' is a stored field):\n  * miniSearch.autoSuggest('zen ar', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  */\n  autoSuggest (queryString, options = {}) {\n    options = { ...defaultAutoSuggestOptions, ...options }\n    const suggestions = this.search(queryString, options).reduce((suggestions, { score, terms }) => {\n      const phrase = terms.join(' ')\n      if (suggestions[phrase] == null) {\n        suggestions[phrase] = { score, terms, count: 1 }\n      } else {\n        suggestions[phrase].score += score\n        suggestions[phrase].count += 1\n      }\n      return suggestions\n    }, {})\n    return Object.entries(suggestions)\n      .map(([suggestion, { score, terms, count }]) => ({ suggestion, terms, score: score / count }))\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n  }\n\n  /**\n  * Number of documents in the index\n  *\n  * @type {number}\n  */\n  get documentCount () {\n    return this._documentCount\n  }\n\n  /**\n  * Deserializes a JSON index (serialized with `miniSearch.toJSON()`) and\n  * instantiates a MiniSearch instance. It should be given the same options\n  * originally used when serializing the index.\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be properly reported in the changelog.\n  *\n  * @param {string} json - JSON-serialized index\n  * @param {Object} options - configuration options, same as the constructor\n  * @return {MiniSearch} an instance of MiniSearch\n  */\n  static loadJSON (json, options) {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return MiniSearch.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n  * Get the default value of an option. It will throw an error if no option with\n  * the given name exists.\n  *\n  * @param {string} optionName - name of the option\n  * @return {*} the default value of the given option\n  *\n  * @example\n  * // Get default tokenizer\n  * MiniSearch.getDefault('tokenize')\n  *\n  * @example\n  * // Get default term processor\n  * MiniSearch.getDefault('processTerm')\n  *\n  * @example\n  * // Unknown options will throw an error\n  * MiniSearch.getDefault('notExisting')\n  * // => throws 'MiniSearch: unknown option \"notExisting\"'\n  */\n  static getDefault (optionName) {\n    const validKeys = Object.keys(defaultOptions)\n    if (validKeys.includes(optionName)) {\n      return defaultOptions[optionName]\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n  * @private\n  */\n  static loadJS (js, options = {}) {\n    const {\n      index: { _tree, _prefix },\n      documentCount,\n      nextId,\n      documentIds,\n      fieldIds,\n      fieldLength,\n      averageFieldLength,\n      storedFields\n    } = js\n    const miniSearch = new MiniSearch(options)\n    miniSearch._index = new SearchableMap(_tree, _prefix)\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._documentIds = documentIds\n    miniSearch._fieldIds = fieldIds\n    miniSearch._fieldLength = fieldLength\n    miniSearch._averageFieldLength = averageFieldLength\n    miniSearch._fieldIds = fieldIds\n    miniSearch._storedFields = storedFields\n    return miniSearch\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  executeQuery (query, options = {}) {\n    options = { ...this._options.searchOptions, ...options }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: boosts[field] || 1 }), options.boost || {})\n\n    const {\n      boostDocument,\n      weights: { fuzzy: fuzzyWeight = 0.9, prefix: prefixWeight = 0.75 }\n    } = options\n\n    const exactMatch = termResults(this, query.term, boosts, boostDocument, this._index.get(query.term))\n\n    if (!query.fuzzy && !query.prefix) { return exactMatch }\n\n    const results = [exactMatch]\n\n    if (query.prefix) {\n      this._index.atPrefix(query.term).forEach((term, data) => {\n        const weightedDistance = (0.3 * (term.length - query.term.length)) / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, prefixWeight, weightedDistance))\n      })\n    }\n\n    if (query.fuzzy) {\n      const maxDistance = query.fuzzy < 1 ? Math.round(query.term.length * query.fuzzy) : query.fuzzy\n      Object.entries(this._index.fuzzyGet(query.term, maxDistance)).forEach(([term, [data, distance]]) => {\n        const weightedDistance = distance / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, fuzzyWeight, weightedDistance))\n      })\n    }\n\n    return results.reduce(combinators[OR], {})\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  combineResults (results, combineWith = OR) {\n    if (results.length === 0) { return {} }\n    const operator = combineWith.toLowerCase()\n    return results.reduce(combinators[operator], null)\n  }\n\n  /**\n  * Allows serialization of the index to JSON, to possibly store it and later\n  * deserialize it with MiniSearch.loadJSON\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be reported in the changelog.\n  *\n  * @return {Object} the serializeable representation of the search index\n  */\n  toJSON () {\n    return {\n      index: this._index,\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: this._documentIds,\n      fieldIds: this._fieldIds,\n      fieldLength: this._fieldLength,\n      averageFieldLength: this._averageFieldLength,\n      storedFields: this._storedFields\n    }\n  }\n}\n\nMiniSearch.SearchableMap = SearchableMap\n\nconst addTerm = function (self, fieldId, documentId, term) {\n  self._index.update(term, indexData => {\n    indexData = indexData || {}\n    const fieldIndex = indexData[fieldId] || { df: 0, ds: {} }\n    if (fieldIndex.ds[documentId] == null) { fieldIndex.df += 1 }\n    fieldIndex.ds[documentId] = (fieldIndex.ds[documentId] || 0) + 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n}\n\nconst removeTerm = function (self, fieldId, documentId, term) {\n  if (!self._index.has(term)) {\n    warnDocumentChanged(self, documentId, fieldId, term)\n    return\n  }\n  self._index.update(term, indexData => {\n    const fieldIndex = indexData[fieldId]\n    if (fieldIndex == null || fieldIndex.ds[documentId] == null) {\n      warnDocumentChanged(self, documentId, fieldId, term)\n      return indexData\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      if (fieldIndex.df <= 1) {\n        delete indexData[fieldId]\n        return indexData\n      }\n      fieldIndex.df -= 1\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      delete fieldIndex.ds[documentId]\n      return indexData\n    }\n    fieldIndex.ds[documentId] -= 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n  if (Object.keys(self._index.get(term)).length === 0) {\n    self._index.delete(term)\n  }\n}\n\nconst warnDocumentChanged = function (self, shortDocumentId, fieldId, term) {\n  if (console == null || console.warn == null) { return }\n  const fieldName = Object.entries(self._fieldIds).find(([name, id]) => id === fieldId)[0]\n  console.warn(`MiniSearch: document with ID ${self._documentIds[shortDocumentId]} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`)\n}\n\nconst addDocumentId = function (self, documentId) {\n  const shortDocumentId = self._nextId.toString(36)\n  self._documentIds[shortDocumentId] = documentId\n  self._documentCount += 1\n  self._nextId += 1\n  return shortDocumentId\n}\n\nconst addFields = function (self, fields) {\n  fields.forEach((field, i) => { self._fieldIds[field] = i })\n}\n\nconst termResults = function (self, term, boosts, boostDocument, indexData, weight = 1, editDistance = 0) {\n  if (indexData == null) { return {} }\n  return Object.entries(boosts).reduce((results, [field, boost]) => {\n    const fieldId = self._fieldIds[field]\n    const { df, ds } = indexData[fieldId] || { ds: {} }\n    Object.entries(ds).forEach(([documentId, tf]) => {\n      const docBoost = boostDocument ? boostDocument(self._documentIds[documentId], term) : 1\n      if (!docBoost) { return }\n      const normalizedLength = self._fieldLength[documentId][fieldId] / self._averageFieldLength[fieldId]\n      results[documentId] = results[documentId] || { score: 0, match: {}, terms: [] }\n      results[documentId].terms.push(term)\n      results[documentId].match[term] = results[documentId].match[term] || []\n      results[documentId].score += docBoost * score(tf, df, self._documentCount, normalizedLength, boost, editDistance)\n      results[documentId].match[term].push(field)\n    })\n    return results\n  }, {})\n}\n\nconst addFieldLength = function (self, documentId, fieldId, count, length) {\n  self._averageFieldLength[fieldId] = self._averageFieldLength[fieldId] || 0\n  const totalLength = (self._averageFieldLength[fieldId] * count) + length\n  self._fieldLength[documentId] = self._fieldLength[documentId] || {}\n  self._fieldLength[documentId][fieldId] = length\n  self._averageFieldLength[fieldId] = totalLength / (count + 1)\n}\n\nconst saveStoredFields = function (self, documentId, doc) {\n  const { storeFields, extractField } = self._options\n  if (storeFields == null || storeFields.length === 0) { return }\n  self._storedFields[documentId] = self._storedFields[documentId] || {}\n\n  storeFields.forEach((fieldName) => {\n    const fieldValue = extractField(doc, fieldName)\n    if (fieldValue === undefined) { return }\n    self._storedFields[documentId][fieldName] = fieldValue\n  })\n}\n\nconst combinators = {\n  [OR]: function (a, b) {\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (combined[documentId] == null) {\n        combined[documentId] = { score, match, terms }\n      } else {\n        combined[documentId].score += score\n        combined[documentId].score *= 1.5\n        combined[documentId].terms = [...combined[documentId].terms, ...terms]\n        Object.assign(combined[documentId].match, match)\n      }\n      return combined\n    }, a || {})\n  },\n  [AND]: function (a, b) {\n    if (a == null) { return b }\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (a[documentId] === undefined) { return combined }\n      combined[documentId] = combined[documentId] || {}\n      combined[documentId].score = a[documentId].score + score\n      combined[documentId].match = { ...a[documentId].match, ...match }\n      combined[documentId].terms = [...a[documentId].terms, ...terms]\n      return combined\n    }, {})\n  }\n}\n\nconst tfIdf = function (tf, df, n) {\n  return tf * Math.log(n / df)\n}\n\nconst score = function (termFrequency, documentFrequency, documentCount, normalizedLength, boost, editDistance) {\n  const weight = boost / (1 + (0.333 * boost * editDistance))\n  return weight * tfIdf(termFrequency, documentFrequency, documentCount) / normalizedLength\n}\n\nconst termToQuery = (options) => (term, i, terms) => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : options.fuzzy\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : options.prefix\n  return { term, fuzzy, prefix }\n}\n\nconst uniq = function (array) {\n  return array.filter((element, i, array) => array.indexOf(element) === i)\n}\n\nconst isTruthy = (x) => !!x\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document, fieldName) => document[fieldName],\n  tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term, _fieldName) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: []\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  weights: {}\n}\n\nconst defaultAutoSuggestOptions = {\n  prefix: (term, i, terms) => i === terms.length - 1\n}\n\n// This regular expression matches any Unicode space or punctuation character\n// Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on\nconst SPACE_OR_PUNCTUATION = /[\\n\\r -#%-*,-/:;?@[-\\]_{}\\u00A0\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u1680\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2000-\\u200A\\u2010-\\u2029\\u202F-\\u2043\\u2045-\\u2051\\u2053-\\u205F\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u3000-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]+/u\n\nexport default MiniSearch\n",
    "static": true,
    "longname": "/Users/luca/Code/minisearch/src/MiniSearch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "OR",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~OR",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "AND",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~AND",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "function",
    "name": "addTerm",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~addTerm",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 572,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "fieldId",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentId",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "function",
    "name": "removeTerm",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~removeTerm",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 582,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "fieldId",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentId",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "function",
    "name": "warnDocumentChanged",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~warnDocumentChanged",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 612,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "shortDocumentId",
        "types": [
          "*"
        ]
      },
      {
        "name": "fieldId",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "function",
    "name": "addDocumentId",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~addDocumentId",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 618,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "function",
    "name": "addFields",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~addFields",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 626,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "function",
    "name": "termResults",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~termResults",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 630,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      },
      {
        "name": "boosts",
        "types": [
          "*"
        ]
      },
      {
        "name": "boostDocument",
        "types": [
          "*"
        ]
      },
      {
        "name": "indexData",
        "types": [
          "*"
        ]
      },
      {
        "name": "weight",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      },
      {
        "name": "editDistance",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "addFieldLength",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~addFieldLength",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 649,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentId",
        "types": [
          "*"
        ]
      },
      {
        "name": "fieldId",
        "types": [
          "*"
        ]
      },
      {
        "name": "count",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "saveStoredFields",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~saveStoredFields",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 657,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentId",
        "types": [
          "*"
        ]
      },
      {
        "name": "doc",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "combinators",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~combinators",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 669,
    "undocument": true,
    "type": {
      "types": [
        "{\"OR\": *, \"AND\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "tfIdf",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~tfIdf",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 696,
    "undocument": true,
    "params": [
      {
        "name": "tf",
        "types": [
          "*"
        ]
      },
      {
        "name": "df",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "function",
    "name": "score",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~score",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 700,
    "undocument": true,
    "params": [
      {
        "name": "termFrequency",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentFrequency",
        "types": [
          "*"
        ]
      },
      {
        "name": "documentCount",
        "types": [
          "*"
        ]
      },
      {
        "name": "normalizedLength",
        "types": [
          "*"
        ]
      },
      {
        "name": "boost",
        "types": [
          "*"
        ]
      },
      {
        "name": "editDistance",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "termToQuery",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~termToQuery",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 705,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"term\": *, \"fuzzy\": *, \"prefix\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "uniq",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~uniq",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 715,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "isTruthy",
    "memberof": "src/MiniSearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~isTruthy",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 719,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "defaultOptions",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~defaultOptions",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 721,
    "undocument": true,
    "type": {
      "types": [
        "{\"idField\": string, \"extractField\": *, \"tokenize\": *, \"processTerm\": *, \"fields\": *, \"searchOptions\": *, \"storeFields\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "variable",
    "name": "defaultSearchOptions",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~defaultSearchOptions",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 731,
    "undocument": true,
    "type": {
      "types": [
        "{\"combineWith\": *, \"prefix\": *, \"fuzzy\": *, \"weights\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "name": "defaultAutoSuggestOptions",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~defaultAutoSuggestOptions",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 738,
    "undocument": true,
    "type": {
      "types": [
        "{\"prefix\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "SPACE_OR_PUNCTUATION",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~SPACE_OR_PUNCTUATION",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 744,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "MiniSearch",
    "memberof": "src/MiniSearch.js",
    "static": true,
    "longname": "src/MiniSearch.js~MiniSearch",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/MiniSearch.js",
    "importStyle": "MiniSearch",
    "description": "MiniSearch is the main entrypoint class, and represents a full-text search\nengine.",
    "examples": [
      "const documents = [\n  {\n    id: 1,\n    title: 'Moby Dick',\n    text: 'Call me Ishmael. Some years ago...',\n    category: 'fiction'\n  },\n  {\n    id: 2,\n    title: 'Zen and the Art of Motorcycle Maintenance',\n    text: 'I can see by my watch...',\n    category: 'fiction'\n  },\n  {\n    id: 3,\n    title: 'Neuromancer',\n    text: 'The sky above the port was...',\n    category: 'fiction'\n  },\n  {\n    id: 4,\n    title: 'Zen and the Art of Archery',\n    text: 'At first sight it must seem...',\n    category: 'non-fiction'\n  },\n  // ...and more\n]\n\n// Create a search engine that indexes the 'title' and 'text' fields for\n// full-text search. Search results will include 'title' and 'category' (plus the\n// id field, that is always stored and returned)\nconst miniSearch = MiniSearch.new({\n  fields: ['title', 'text'],\n  storeFields: ['title', 'category']\n})\n\n// Add documents to the index\nminiSearch.addAll(documents)\n\n// Search for documents:\nlet results = miniSearch.search('zen art motorcycle')\n// => [\n  { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n  { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n]"
    ],
    "lineNumber": 57,
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "// Create a search engine that indexes the 'title' and 'text' fields of your\n// documents:\nconst miniSearch = MiniSearch.new({ fields: ['title', 'text'] })",
      "// Your documents are assumed to include a unique 'id' field, but if you want\n// to use a different field for document identification, you can set the\n// 'idField' option:\nconst miniSearch = MiniSearch.new({ idField: 'key', fields: ['title', 'text'] })",
      "// The full set of options (here with their default value) is:\nconst miniSearch = MiniSearch.new({\n  // idField: field that uniquely identifies a document\n  idField: 'id',\n\n  // extractField: function used to get the value of a field in a document.\n  // By default, it assumes the document is a flat object with field names as\n  // property keys and field values as string property values, but custom logic\n  // can be implemented by setting this option to a custom extractor function.\n  extractField: (document, fieldName) => document[fieldName],\n\n  // tokenize: function used to split fields into individual terms. By\n  // default, it is also used to tokenize search queries, unless a specific\n  // `tokenize` search option is supplied. When tokenizing an indexed field,\n  // the field name is passed as the second argument.\n  tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n\n  // processTerm: function used to process each tokenized term before\n  // indexing. It can be used for stemming and normalization. Return a falsy\n  // value in order to discard a term. By default, it is also used to process\n  // search queries, unless a specific `processTerm` option is supplied as a\n  // search option. When processing a term from a indexed field, the field\n  // name is passed as the second argument.\n  processTerm: (term, _fieldName) => term.toLowerCase(),\n\n  // searchOptions: default search options, see the `search` method for\n  // details\n  searchOptions: undefined,\n\n  // fields: document fields to be indexed. Mandatory, but not set by default\n  fields: undefined\n\n  // storeFields: document fields to be stored and returned as part of the\n  // search results.\n  storeFields: []\n})"
    ],
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Configuration options"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "options.fields",
        "description": "Fields to be indexed. Required."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'id'",
        "defaultRaw": "'id'",
        "name": "options.idField",
        "description": "ID field, uniquely identifying a document"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.storeFields",
        "description": "Fields to store, so that search results would include them. By default none, so resuts would only contain the id field."
      },
      {
        "nullable": null,
        "types": [
          "function(document: Object, fieldName: string): string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.extractField",
        "description": "Function used to get the value of a field in a document"
      },
      {
        "nullable": null,
        "types": [
          "function(text: string, [fieldName]: string): Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.tokenize",
        "description": "Function used to split a field into individual terms"
      },
      {
        "nullable": null,
        "types": [
          "function(term: string, [fieldName]: string): string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.processTerm",
        "description": "Function used to process a term before indexing it or searching"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.searchOptions",
        "description": "Default search options (see the `search` method for details)"
      }
    ]
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "_options",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_options",
    "access": "private",
    "description": null,
    "lineNumber": 119,
    "ignore": true,
    "type": {
      "types": [
        "{...defaultOptions: Object, ...options: Object}"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "_index",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_index",
    "access": "private",
    "description": null,
    "lineNumber": 129,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "_documentCount",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_documentCount",
    "access": "private",
    "description": null,
    "lineNumber": 132,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "_documentIds",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_documentIds",
    "access": "private",
    "description": null,
    "lineNumber": 135,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "_fieldIds",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_fieldIds",
    "access": "private",
    "description": null,
    "lineNumber": 138,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "_fieldLength",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_fieldLength",
    "access": "private",
    "description": null,
    "lineNumber": 141,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "_averageFieldLength",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_averageFieldLength",
    "access": "private",
    "description": null,
    "lineNumber": 144,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "_nextId",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_nextId",
    "access": "private",
    "description": null,
    "lineNumber": 147,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "_storedFields",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#_storedFields",
    "access": "private",
    "description": null,
    "lineNumber": 150,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "add",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#add",
    "access": "public",
    "description": "Adds a document to the index",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document to be indexed"
      }
    ],
    "return": null
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "addAll",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#addAll",
    "access": "public",
    "description": "Adds all the given documents to the index",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "documents",
        "description": "an array of documents to be indexed"
      }
    ],
    "return": null
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "addAllAsync",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#addAllAsync",
    "access": "public",
    "description": "Adds all the given documents to the index asynchronously.\n\nReturns a promise that resolves to undefined when the indexing is done. This\nmethod is useful when index many documents, to avoid blocking the main\nthread. The indexing is performed asynchronously and in chunks.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "documents",
        "description": "an array of documents to be indexed"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Configuration options"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.chunkSize",
        "description": "Size of the document chunks indexed, 10 by default"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise resolving to `null` when the indexing is done"
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "remove",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#remove",
    "access": "public",
    "description": "Removes the given document from the index.\n\nThe document to delete must NOT have changed between indexing and deletion,\notherwise the index will be corrupted. Therefore, when reindexing a document\nafter a change, the correct order of operations is:\n\n  1. remove old version\n  2. apply changes\n  3. index new version",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "document",
        "description": "the document to be indexed"
      }
    ],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "search",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#search",
    "access": "public",
    "description": "Search for documents matching the given search query.\n\nThe result is a list of scored document IDs matching the query, sorted by\ndescending score, and each including data about which terms were matched and\nin which fields.",
    "examples": [
      "// Search for \"zen art motorcycle\" with default options: terms have to match\n// exactly, and individual terms are joined with OR\nminiSearch.search('zen art motorcycle')\n// => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]",
      "// Search only in the 'title' field\nminiSearch.search('zen', { fields: ['title'] })",
      "// Boost a field\nminiSearch.search('zen', { boost: { title: 2 } })",
      "// Search for \"moto\" with prefix search (it will match documents\n// containing terms that start with \"moto\" or \"neuro\")\nminiSearch.search('moto neuro', { prefix: true })",
      "// Search for \"ismael\" with fuzzy search (it will match documents containing\n// terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n// (rounded to nearest integer)\nminiSearch.search('ismael', { fuzzy: 0.2 })",
      "// Mix of exact match, prefix search, and fuzzy search\nminiSearch.search('ismael mob', {\n prefix: true,\n fuzzy: 0.2\n})",
      "// Perform fuzzy and prefix search depending on the search term. Here\n// performing prefix and fuzzy search only on terms longer than 3 characters\nminiSearch.search('ismael mob', {\n prefix: term => term.length > 3\n fuzzy: term => term.length > 3 ? 0.2 : null\n})",
      "// Combine search terms with AND (to match only documents that contain both\n// \"motorcycle\" and \"art\")\nminiSearch.search('motorcycle art', { combineWith: 'AND' })",
      "// Filter only results in the 'fiction' category (assuming that 'category'\n// is a stored field)\nminiSearch.search('motorcycle art', {\n  filter: (result) => result.category === 'fiction'\n})"
    ],
    "lineNumber": 324,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "queryString",
        "description": "Query string to search for"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fields",
        "description": "Fields to search in. If omitted, all fields are searched"
      },
      {
        "nullable": null,
        "types": [
          "Object<string, number>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.boost",
        "description": "Key-value object of boosting values for fields"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "function(term: string, i: number, terms: Array<string>): boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.prefix",
        "description": "Whether to perform prefix search. Value can be a boolean, or a function computing the boolean from each tokenized and processed query term. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms."
      },
      {
        "nullable": null,
        "types": [
          "number",
          "function(term: string, i: number, terms: Array<string>): boolean",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.fuzzy",
        "description": "If set to a number greater than or equal 1, it performs fuzzy search within a maximum edit distance equal to that value. If set to a number less than 1, it performs fuzzy search with a maximum edit distance equal to the term length times the value, rouded at the nearest integer. If set to a function, it calls the function for each tokenized and processed query term and expects a numeric value indicating the maximum edit distance, or a falsy falue if fuzzy search should not be performed. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'OR'",
        "defaultRaw": "'OR'",
        "name": "options.combineWith",
        "description": "How to combine term queries (it can be 'OR' or 'AND')"
      },
      {
        "nullable": null,
        "types": [
          "function(query: string): Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.tokenize",
        "description": "Function used to tokenize the search query. It defaults to the same tokenizer used for indexing."
      },
      {
        "nullable": null,
        "types": [
          "function(term: string): string",
          "null",
          "undefined",
          "false"
        ],
        "spread": false,
        "optional": true,
        "name": "options.processTerm",
        "description": "Function used to process each search term. Return a falsy value to discard a term. Defaults to the same function used to process terms upon indexing."
      },
      {
        "nullable": null,
        "types": [
          "function(result: Object): boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.filter",
        "description": "Function used to filter search results, for example on the basis of stored fields"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<{ id: any, score: number, match: Object }>"
      ],
      "spread": false,
      "description": "A sorted array of scored document IDs matching the search"
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "autoSuggest",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#autoSuggest",
    "access": "public",
    "description": "Provide suggestions for the given search query\n\nThe result is a list of suggested modified search queries, derived from the\ngiven search query, each with a relevance score, sorted by descending score.",
    "examples": [
      "// Get suggestions for 'neuro':\nminiSearch.autoSuggest('neuro')\n// => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]",
      "// Get suggestions for 'zen ar':\nminiSearch.autoSuggest('zen ar')\n// => [\n//  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n//  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n// ]",
      "// Correct spelling mistakes using fuzzy search:\nminiSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n// => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]",
      "// Get suggestions for 'zen ar', but only within the 'fiction' category\n// (assuming that 'category' is a stored field):\nminiSearch.autoSuggest('zen ar', {\n  filter: (result) => result.category === 'fiction'\n})\n// => [\n//  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n//  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n// ]"
    ],
    "lineNumber": 391,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "queryString",
        "description": "Query string to be expanded into suggestions"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Search options. The supported options and default values are the same as for the `search` method, except that by default prefix search is performed on the last term in the query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<{ suggestion: string, score: number }>"
      ],
      "spread": false,
      "description": "A sorted array of suggestions sorted by relevance score."
    }
  },
  {
    "__docId__": 87,
    "kind": "get",
    "name": "documentCount",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#documentCount",
    "access": "public",
    "description": "Number of documents in the index",
    "lineNumber": 413,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "loadJSON",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~MiniSearch.loadJSON",
    "access": "public",
    "description": "Deserializes a JSON index (serialized with `miniSearch.toJSON()`) and\ninstantiates a MiniSearch instance. It should be given the same options\noriginally used when serializing the index.\n\n**Warning:** JSON (de)serialization of the index is currently tightly\ncoupled to the index implementation. For this reason, the current\nimplementation is to be considered a _beta_ feature, subject to breaking\nchanges changes in future releases. If a breaking change is introduced,\nthough, it will be properly reported in the changelog.",
    "lineNumber": 432,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "json",
        "description": "JSON-serialized index"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "configuration options, same as the constructor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MiniSearch"
      ],
      "spread": false,
      "description": "an instance of MiniSearch"
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "getDefault",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~MiniSearch.getDefault",
    "access": "public",
    "description": "Get the default value of an option. It will throw an error if no option with\nthe given name exists.",
    "examples": [
      "// Get default tokenizer\nMiniSearch.getDefault('tokenize')",
      "// Get default term processor\nMiniSearch.getDefault('processTerm')",
      "// Unknown options will throw an error\nMiniSearch.getDefault('notExisting')\n// => throws 'MiniSearch: unknown option \"notExisting\"'"
    ],
    "lineNumber": 459,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "optionName",
        "description": "name of the option"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the default value of the given option"
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "loadJS",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/MiniSearch.js~MiniSearch.loadJS",
    "access": "private",
    "description": "",
    "lineNumber": 471,
    "ignore": true,
    "params": [
      {
        "name": "js",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "executeQuery",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#executeQuery",
    "access": "private",
    "description": "",
    "lineNumber": 499,
    "ignore": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "combineResults",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#combineResults",
    "access": "private",
    "description": "",
    "lineNumber": 538,
    "ignore": true,
    "params": [
      {
        "name": "results",
        "types": [
          "*"
        ]
      },
      {
        "name": "combineWith",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "OR",
        "defaultValue": "OR"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "toJSON",
    "memberof": "src/MiniSearch.js~MiniSearch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/MiniSearch.js~MiniSearch#toJSON",
    "access": "public",
    "description": "Allows serialization of the index to JSON, to possibly store it and later\ndeserialize it with MiniSearch.loadJSON\n\n**Warning:** JSON (de)serialization of the index is currently tightly\ncoupled to the index implementation. For this reason, the current\nimplementation is to be considered a _beta_ feature, subject to breaking\nchanges changes in future releases. If a breaking change is introduced,\nthough, it will be reported in the changelog.",
    "lineNumber": 556,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the serializeable representation of the search index"
    },
    "params": []
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/SearchableMap/SearchableMap.js",
    "content": "import { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator.js'\nimport fuzzySearch from './fuzzySearch.js'\n\n/**\n* A class implementing the same interface as a standard JavaScript `Map` with\n* string keys, but adding support for efficiently searching entries with prefix\n* or fuzzy search. This is the class internally used by `MiniSearch` as the\n* inverted index data structure. The implementation is a radix tree (compressed\n* prefix tree).\n*\n* @implements {Map}\n*/\nclass SearchableMap {\n  constructor (tree = {}, prefix = '') {\n    /** @private */\n    this._tree = tree\n    /** @private */\n    this._prefix = prefix\n  }\n\n  /**\n  * Creates and returns a mutable view of this `SearchableMap`, containing only\n  * entries that share the given prefix.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set(\"unicorn\", 1)\n  * map.set(\"universe\", 2)\n  * map.set(\"university\", 3)\n  * map.set(\"unique\", 4)\n  * map.set(\"hello\", 5)\n  *\n  * let uni = map.atPrefix(\"uni\")\n  * uni.get(\"unique\") // => 4\n  * uni.get(\"unicorn\") // => 1\n  * uni.get(\"hello\") // => undefined\n  *\n  * let univer = map.atPrefix(\"univer\")\n  * uni.get(\"unique\") // => undefined\n  * uni.get(\"universe\") // => 2\n  * uni.get(\"university\") // => 3\n  *\n  * @param {string} prefix - The prefix\n  * @return {SearchableMap} A `SearchableMap` representing a mutable view of the original Map at the given prefix\n  */\n  atPrefix (prefix) {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n      const nodeKey = Object.keys(parentNode).find(k => k !== LEAF && k.startsWith(key))\n      if (nodeKey !== undefined) {\n        return new SearchableMap({ [nodeKey.slice(key.length)]: parentNode[nodeKey] }, prefix)\n      }\n    }\n    return new SearchableMap(node || {}, prefix)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n  * @return {undefined}\n  */\n  clear () {\n    delete this._size\n    this._tree = {}\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n  * @param {string} key\n  * @return {undefined}\n  */\n  delete (key) {\n    delete this._size\n    return remove(this._tree, key)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n  * @return {Iterator}\n  */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n  * @param {function(key: string, value: any): any} fn\n  * @return {undefined}\n  */\n  forEach (fn) {\n    for (let [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n  * Returns a key-value object of all the entries that have a key within the\n  * given edit distance from the search key. The keys of the returned object are\n  * the matching keys, while the values are two-elements arrays where the first\n  * element is the value associated to the key, and the second is the edit\n  * distance of the key to the search key.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set('hello', 'world')\n  * map.set('hell', 'yeah')\n  * map.set('ciao', 'mondo')\n  *\n  * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n  * map.fuzzyGet('hallo', 2)\n  * // => { \"hello\": [\"world\", 1], \"hell\": [\"yeah\", 2] }\n  *\n  * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n  * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n  * // (change \"e\" to \"a\", delete \"o\")\n  *\n  * @param {string} key - The search key\n  * @param {number} maxEditDistance - The maximum edit distance\n  * @return {Object<string, Array>} A key-value object of the matching keys to their value and edit distance\n  */\n  fuzzyGet (key, maxEditDistance) {\n    return fuzzySearch(this._tree, key, maxEditDistance)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n  * @param {string} key\n  * @return {any}\n  */\n  get (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined ? node[LEAF] : undefined\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n  * @param {string} key\n  * @return {boolean}\n  */\n  has (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.hasOwnProperty(LEAF)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n  * @return {Iterator}\n  */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n  * @param {string} key\n  * @param {any} value\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  set (key, value) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = value\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n  * @type {number}\n  */\n  get size () {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n    this.forEach(() => { this._size += 1 })\n    return this._size\n  }\n\n  /**\n  * Updates the value at the given key using the provided function. The function\n  * is called with the current value at the key, and its return value is used as\n  * the new value to be set.\n  *\n  * @example\n  * // Increment the current value by one\n  * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n  *\n  * @param {string} key - The key\n  * @param {function(currentValue: any): any} fn - The function used to compute the new value from the current one\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  update (key, fn) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = fn(node[LEAF])\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n  * @return {Iterator}\n  */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n  * @return {Iterator}\n  */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n}\n\n/**\n* Creates a `SearchableMap` from an `Iterable` of entries\n*\n* @param {Iterable|Array} entries - Entries to be inserted in the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.from = function (entries) {\n  const tree = new SearchableMap()\n  for (let [key, value] of entries) {\n    tree.set(key, value)\n  }\n  return tree\n}\n\n/**\n* Creates a `SearchableMap` from the iterable properties of a JavaScript object\n*\n* @param {Object} object - Object of entries for the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.fromObject = function (object) {\n  return SearchableMap.from(Object.entries(object))\n}\n\nconst trackDown = function (tree, key, path = []) {\n  if (key.length === 0) { return [tree, path] }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return trackDown(undefined, '', [...path, [tree, key]]) }\n  return trackDown(tree[nodeKey], key.slice(nodeKey.length), [...path, [tree, nodeKey]])\n}\n\nconst lookup = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return undefined }\n  return lookup(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst createPath = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) {\n    const toSplit = Object.keys(tree).find(k => k !== LEAF && k.startsWith(key[0]))\n    if (toSplit === undefined) {\n      tree[key] = {}\n    } else {\n      const prefix = commonPrefix(key, toSplit)\n      tree[prefix] = { [toSplit.slice(prefix.length)]: tree[toSplit] }\n      delete tree[toSplit]\n      return createPath(tree[prefix], key.slice(prefix.length))\n    }\n    return tree[key]\n  }\n  return createPath(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst commonPrefix = function (a, b, i = 0, length = Math.min(a.length, b.length), prefix = '') {\n  if (i >= length) { return prefix }\n  if (a[i] !== b[i]) { return prefix }\n  return commonPrefix(a, b, i + 1, length, prefix + a[i])\n}\n\nconst remove = function (tree, key) {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  delete node[LEAF]\n  const keys = Object.keys(node)\n  if (keys.length === 0) { cleanup(path) }\n  if (keys.length === 1) { merge(path, keys[0], node[keys[0]]) }\n}\n\nconst cleanup = function (path) {\n  if (path.length === 0) { return }\n  const [node, key] = last(path)\n  delete node[key]\n  if (Object.keys(node).length === 0) {\n    cleanup(path.slice(0, -1))\n  }\n}\n\nconst merge = function (path, key, value) {\n  if (path.length === 0) { return }\n  const [node, nodeKey] = last(path)\n  node[nodeKey + key] = value\n  delete node[nodeKey]\n}\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport default SearchableMap\nexport { SearchableMap }\n",
    "static": true,
    "longname": "/Users/luca/Code/minisearch/src/SearchableMap/SearchableMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "function",
    "name": "from",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~from",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": "Creates a `SearchableMap` from an `Iterable` of entries",
    "lineNumber": 224,
    "params": [
      {
        "nullable": null,
        "types": [
          "Iterable",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "entries",
        "description": "Entries to be inserted in the `SearchableMap`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "SearchableMap"
      ],
      "spread": false,
      "description": "A new `SearchableMap` with the given entries"
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "function",
    "name": "fromObject",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~fromObject",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": "Creates a `SearchableMap` from the iterable properties of a JavaScript object",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "Object of entries for the `SearchableMap`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "SearchableMap"
      ],
      "spread": false,
      "description": "A new `SearchableMap` with the given entries"
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "function",
    "name": "trackDown",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~trackDown",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "params": [
      {
        "name": "tree",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "function",
    "name": "lookup",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~lookup",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "params": [
      {
        "name": "tree",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "createPath",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~createPath",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "params": [
      {
        "name": "tree",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 100,
    "kind": "function",
    "name": "commonPrefix",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~commonPrefix",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "length",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 101,
    "kind": "function",
    "name": "remove",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~remove",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "tree",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 102,
    "kind": "function",
    "name": "cleanup",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~cleanup",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 289,
    "undocument": true,
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "function",
    "name": "merge",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~merge",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 104,
    "kind": "function",
    "name": "last",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~last",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 305,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 105,
    "kind": "class",
    "name": "SearchableMap",
    "memberof": "src/SearchableMap/SearchableMap.js",
    "static": true,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/SearchableMap.js",
    "importStyle": "SearchableMap",
    "description": "A class implementing the same interface as a standard JavaScript `Map` with\nstring keys, but adding support for efficiently searching entries with prefix\nor fuzzy search. This is the class internally used by `MiniSearch` as the\ninverted index data structure. The implementation is a radix tree (compressed\nprefix tree).",
    "lineNumber": 13,
    "interface": false,
    "implements": [
      "Map"
    ]
  },
  {
    "__docId__": 106,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_tree",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#_tree",
    "access": "private",
    "description": null,
    "lineNumber": 16,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_prefix",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#_prefix",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "atPrefix",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#atPrefix",
    "access": "public",
    "description": "Creates and returns a mutable view of this `SearchableMap`, containing only\nentries that share the given prefix.",
    "examples": [
      "let map = new SearchableMap()\nmap.set(\"unicorn\", 1)\nmap.set(\"universe\", 2)\nmap.set(\"university\", 3)\nmap.set(\"unique\", 4)\nmap.set(\"hello\", 5)\n\nlet uni = map.atPrefix(\"uni\")\nuni.get(\"unique\") // => 4\nuni.get(\"unicorn\") // => 1\nuni.get(\"hello\") // => undefined\n\nlet univer = map.atPrefix(\"univer\")\nuni.get(\"unique\") // => undefined\nuni.get(\"universe\") // => 2\nuni.get(\"university\") // => 3"
    ],
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": "The prefix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "SearchableMap"
      ],
      "spread": false,
      "description": "A `SearchableMap` representing a mutable view of the original Map at the given prefix"
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "clear",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#clear",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear"
    ],
    "lineNumber": 63,
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "delete",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#delete",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete"
    ],
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "entries",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#entries",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries"
    ],
    "lineNumber": 82,
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#forEach",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach"
    ],
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(key: string, value: any): any"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "fuzzyGet",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#fuzzyGet",
    "access": "public",
    "description": "Returns a key-value object of all the entries that have a key within the\ngiven edit distance from the search key. The keys of the returned object are\nthe matching keys, while the values are two-elements arrays where the first\nelement is the value associated to the key, and the second is the edit\ndistance of the key to the search key.",
    "examples": [
      "let map = new SearchableMap()\nmap.set('hello', 'world')\nmap.set('hell', 'yeah')\nmap.set('ciao', 'mondo')\n\n// Get all entries that match the key 'hallo' with a maximum edit distance of 2\nmap.fuzzyGet('hallo', 2)\n// => { \"hello\": [\"world\", 1], \"hell\": [\"yeah\", 2] }\n\n// In the example, the \"hello\" key has value \"world\" and edit distance of 1\n// (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n// (change \"e\" to \"a\", delete \"o\")"
    ],
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "The search key"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxEditDistance",
        "description": "The maximum edit distance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object<string, Array>"
      ],
      "spread": false,
      "description": "A key-value object of the matching keys to their value and edit distance"
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "get",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#get",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get"
    ],
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "has",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#has",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has"
    ],
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "keys",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#keys",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys"
    ],
    "lineNumber": 150,
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "set",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#set",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set"
    ],
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "SearchableMap"
      ],
      "spread": false,
      "description": "The `SearchableMap` itself, to allow chaining"
    }
  },
  {
    "__docId__": 120,
    "kind": "get",
    "name": "size",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#size",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size"
    ],
    "lineNumber": 172,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "_size",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#_size",
    "access": "private",
    "description": null,
    "lineNumber": 175,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "update",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#update",
    "access": "public",
    "description": "Updates the value at the given key using the provided function. The function\nis called with the current value at the key, and its return value is used as\nthe new value to be set.",
    "examples": [
      "// Increment the current value by one\nsearchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)"
    ],
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "The key"
      },
      {
        "nullable": null,
        "types": [
          "function(currentValue: any): any"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "The function used to compute the new value from the current one"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "SearchableMap"
      ],
      "spread": false,
      "description": "The `SearchableMap` itself, to allow chaining"
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "values",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#values",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values"
    ],
    "lineNumber": 205,
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/SearchableMap/SearchableMap.js~SearchableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/SearchableMap.js~SearchableMap#[Symbol.iterator]",
    "access": "public",
    "description": "",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator"
    ],
    "lineNumber": 213,
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 126,
    "kind": "file",
    "name": "src/SearchableMap/TreeIterator.js",
    "content": "/**\n* @private\n*/\nclass TreeIterator {\n  constructor (set, type) {\n    const node = set._tree\n    const keys = Object.keys(node)\n    this.set = set\n    this.type = type\n    this.path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next () {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive () {\n    if (this.path.length === 0) { return { done: true } }\n    const { node, keys } = last(this.path)\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n    this.path.push({ node: node[last(keys)], keys: Object.keys(node[last(keys)]) })\n    return this.dive()\n  }\n\n  backtrack () {\n    if (this.path.length === 0) { return }\n    last(this.path).keys.pop()\n    if (last(this.path).keys.length > 0) { return }\n    this.path.pop()\n    this.backtrack()\n  }\n\n  key () {\n    return this.set._prefix + this.path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value () {\n    return last(this.path).node[LEAF]\n  }\n\n  result () {\n    if (this.type === VALUES) { return this.value() }\n    if (this.type === KEYS) { return this.key() }\n    return [this.key(), this.value()]\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = ''\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n",
    "static": true,
    "longname": "/Users/luca/Code/minisearch/src/SearchableMap/TreeIterator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 127,
    "kind": "function",
    "name": "last",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~last",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 128,
    "kind": "class",
    "name": "TreeIterator",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "access": "private",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": "{TreeIterator}",
    "description": "",
    "lineNumber": 4,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "set",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#set",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "type",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#type",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "path",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#path",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "next",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#next",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "dive",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#dive",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "backtrack",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#backtrack",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "key",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#key",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "value",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#value",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "result",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#result",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "[Symbol.iterator]",
    "memberof": "src/SearchableMap/TreeIterator.js~TreeIterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/SearchableMap/TreeIterator.js~TreeIterator#[Symbol.iterator]",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "ENTRIES",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~ENTRIES",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": "{ENTRIES}",
    "description": null,
    "lineNumber": 58,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "variable",
    "name": "KEYS",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~KEYS",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": "{KEYS}",
    "description": null,
    "lineNumber": 61,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "variable",
    "name": "VALUES",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~VALUES",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": "{VALUES}",
    "description": null,
    "lineNumber": 64,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "variable",
    "name": "LEAF",
    "memberof": "src/SearchableMap/TreeIterator.js",
    "static": true,
    "longname": "src/SearchableMap/TreeIterator.js~LEAF",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/TreeIterator.js",
    "importStyle": "{LEAF}",
    "description": null,
    "lineNumber": 67,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "file",
    "name": "src/SearchableMap/fuzzySearch.js",
    "content": "import { LEAF } from './TreeIterator.js'\n\n/**\n* @ignore\n*/\nexport const fuzzySearch = function (node, query, maxDistance) {\n  const stack = [{ distance: 0, i: 0, key: '', node }]\n  const results = {}\n  const innerStack = []\n\n  while (stack.length > 0) {\n    const { node, distance, key, i, edit } = stack.pop()\n    Object.keys(node).forEach((k) => {\n      if (k === LEAF) {\n        const totDistance = distance + (query.length - i)\n        const [, d] = results[key] || [null, Infinity]\n        if (totDistance <= maxDistance && totDistance < d) {\n          results[key] = [node[k], totDistance]\n        }\n      } else {\n        withinDistance(query, k, maxDistance - distance, i, edit, innerStack).forEach(({ distance: d, i, edit }) => {\n          stack.push({ node: node[k], distance: distance + d, key: key + k, i, edit })\n        })\n      }\n    })\n  }\n  return results\n}\n\n/**\n* @ignore\n*/\nexport const withinDistance = function (a, b, maxDistance, i, edit, stack) {\n  stack.push({ distance: 0, ia: i, ib: 0, edit })\n  const results = []\n\n  while (stack.length > 0) {\n    const { distance, ia, ib, edit } = stack.pop()\n\n    if (ib === b.length) {\n      results.push({ distance, i: ia, edit })\n      continue\n    }\n\n    if (a[ia] === b[ib]) {\n      stack.push({ distance, ia: ia + 1, ib: ib + 1, edit: NONE })\n    } else {\n      if (distance >= maxDistance) { continue }\n\n      if (edit !== ADD) {\n        stack.push({ distance: distance + 1, ia, ib: ib + 1, edit: DELETE })\n      }\n\n      if (ia < a.length) {\n        if (edit !== DELETE) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib, edit: ADD })\n        }\n\n        if (edit !== DELETE && edit !== ADD) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib: ib + 1, edit: CHANGE })\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nconst NONE = 0\nconst CHANGE = 1\nconst ADD = 2\nconst DELETE = 3\n\nexport default fuzzySearch\n",
    "static": true,
    "longname": "/Users/luca/Code/minisearch/src/SearchableMap/fuzzySearch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 145,
    "kind": "function",
    "name": "fuzzySearch",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~fuzzySearch",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": "{fuzzySearch}",
    "description": "",
    "lineNumber": 6,
    "ignore": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "maxDistance",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "function",
    "name": "withinDistance",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~withinDistance",
    "access": "public",
    "export": true,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": "{withinDistance}",
    "description": "",
    "lineNumber": 33,
    "ignore": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "maxDistance",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "edit",
        "types": [
          "*"
        ]
      },
      {
        "name": "stack",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "NONE",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~NONE",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "variable",
    "name": "CHANGE",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~CHANGE",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "variable",
    "name": "ADD",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~ADD",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "variable",
    "name": "DELETE",
    "memberof": "src/SearchableMap/fuzzySearch.js",
    "static": true,
    "longname": "src/SearchableMap/fuzzySearch.js~DELETE",
    "access": "public",
    "export": false,
    "importPath": "minisearch/src/SearchableMap/fuzzySearch.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 151,
    "kind": "file",
    "name": "src/index.js",
    "content": "import MiniSearch from './MiniSearch.js'\n\nexport default MiniSearch",
    "static": true,
    "longname": "/Users/luca/Code/minisearch/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# [![MiniSearch](https://lucaong.github.io/minisearch/MiniSearch.svg)](https://lucaong.github.io/minisearch/) MiniSearch\n\n[![Build Status](https://travis-ci.org/lucaong/minisearch.svg?branch=master)](https://travis-ci.org/lucaong/minisearch)\n[![Coverage Status](https://coveralls.io/repos/github/lucaong/minisearch/badge.svg?branch=master)](https://coveralls.io/github/lucaong/minisearch?branch=master)\n[![Minzipped Size](https://img.shields.io/bundlephobia/minzip/minisearch.svg?style=flat)](https://bundlephobia.com/result?p=minisearch)\n[![](https://data.jsdelivr.com/v1/package/npm/minisearch/badge?style=rounded)](https://www.jsdelivr.com/package/npm/minisearch)\n\n`MiniSearch` is a tiny but powerful in-memory fulltext search engine written in\nJavaScript. It is respectful of resources, and it can comfortably run both in\nNode and in the browser.\n\nTry out the [demo application](https://lucaong.github.io/minisearch/examples/).\n\nFind the complete [documentation and API reference\nhere](https://lucaong.github.io/minisearch), and more background about\n`MiniSearch`, including a comparison with other similar libraries, in [this blog\npost](https://lucaongaro.eu/blog/2019/01/30/minisearch-client-side-fulltext-search-engine.html).\n\n\n## Use case\n\n`MiniSearch` addresses use cases where full-text search features are needed\n(e.g. prefix search, fuzzy search, ranking, boosting of fields…), but the data\nto be indexed can fit locally in the process memory. While you won't index the\nwhole Internet with it, there are surprisingly many use cases that are served\nwell by `MiniSearch`. By storing the index in local memory, `MiniSearch` can\nwork offline, and can process queries quickly, without network latency.\n\nA prominent use-case is real time search \"as you type\" in web and mobile\napplications, where keeping the index on the client enables fast and reactive\nUIs, removing the need to make requests to a search server.\n\n\n## Features\n\n  * Memory-efficient index, designed to support memory-constrained use cases\n    like mobile browsers.\n\n  * Exact match, prefix search, fuzzy match, field boosting\n\n  * Auto-suggestion engine, for auto-completion of search queries\n\n  * Documents can be added and removed from the index at any time\n\n  * Zero external dependencies\n\n`MiniSearch` strives to expose a simple API that provides the building blocks to\nbuild custom solutions, while keeping a small and well tested codebase.\n\n\n## Installation\n\nWith `npm`:\n\n```\nnpm install --save minisearch\n```\n\nWith `yarn`:\n\n```\nyarn add minisearch\n```\n\nThen `require` or `import` it in your project.\n\nAlternatively, if you prefer to use a `<script>` tag, you can require MiniSearch\nfrom a CDN:\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/minisearch@2.0.6/dist/minisearch.min.js\"></script>\n```\n\nFinally, if you want to manually build the library, clone the repository and run\n`yarn build` (or `yarn build-minified` for a minified version + source maps).\nThe compiled source will be created in the `dist` folder.\n\n\n## Usage\n\n### Basic usage\n\n```javascript\n// A collection of documents for our examples\nconst documents = [\n  {\n    id: 1,\n    title: 'Moby Dick',\n    text: 'Call me Ishmael. Some years ago...',\n    category: 'fiction'\n  },\n  {\n    id: 2,\n    title: 'Zen and the Art of Motorcycle Maintenance',\n    text: 'I can see by my watch...',\n    category: 'fiction'\n  },\n  {\n    id: 3,\n    title: 'Neuromancer',\n    text: 'The sky above the port was...',\n    category: 'fiction'\n  },\n  {\n    id: 4,\n    title: 'Zen and the Art of Archery',\n    text: 'At first sight it must seem...',\n    category: 'non-fiction'\n  },\n  // ...and more\n]\n\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'], // fields to index for full-text search\n  storeFields: ['title', 'category'] // fields to return with search results\n})\n\n// Index all documents\nminiSearch.addAll(documents)\n\n// Search with default options\nlet results = miniSearch.search('zen art motorcycle')\n// => [\n//   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258, match: { ... } },\n//   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629, match: { ... } }\n// ]\n```\n\n### Search options\n\n`MiniSearch` supports several options for more advanced search behavior:\n\n```javascript\n// Search only specific fields\nminiSearch.search('zen', { fields: ['title'] })\n\n// Boost some fields (here \"title\")\nminiSearch.search('zen', { boost: { title: 2 } })\n\n// Prefix search (so that 'moto' will match 'motorcycle')\nminiSearch.search('moto', { prefix: true })\n\n// Search within a specific category\nminiSearch.search('zen', {\n  filter: (result) => result.category === 'fiction'\n})\n\n// Fuzzy search, in this example, with a max edit distance of 0.2 * term length,\n// rounded to nearest integer. The mispelled 'ismael' will match 'ishmael'.\nminiSearch.search('ismael', { fuzzy: 0.2 })\n\n// You can set the default search options upon initialization\nminiSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  searchOptions: {\n    boost: { title: 2 },\n    fuzzy: 0.2\n  }\n})\nminiSearch.addAll(documents)\n\n// It will now by default perform fuzzy search and boost \"title\":\nminiSearch.search('zen and motorcycles')\n```\n\n### Auto suggestions\n\n`MiniSearch` can suggest search queries given an incomplete query:\n\n```javascript\nminiSearch.autoSuggest('zen ar')\n// => [ { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n//      { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\n```\n\nThe `autoSuggest` method takes the same options as the `search` method, so you\ncan get suggestions for misspelled words using fuzzy search:\n\n```javascript\nminiSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n// => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n```\n\nSuggestions are ranked by the relevance of the documents that would be returned\nby that search.\n\nSometimes, you might need to filter auto suggestions to, say, only a specific\ncategory. You can do so by providing a `filter` option:\n\n```javascript\nminiSearch.autoSuggest('zen ar', {\n  filter: (result) => result.category === 'fiction'\n})\n// => [ { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\n```\n\n### Field extraction\n\nBy default, documents are assumed to be plain key-value objects with field names\nas keys and field values as string values. In order to support custom field\nextraction logic (for example for nested fields, or non-string field values\nneeding processing before tokenization), a custom field extractor function can\nbe passed as the `extractField` option:\n\n```javascript\n// Assuming that our documents look like:\nconst documents = [\n  { id: 1, title: 'Moby Dick', author: { name: 'Herman Melville' }, tags: ['fiction', 'whale'] },\n  { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', author: { name: 'Robert Pirsig' }, tags: ['fiction', 'zen'] },\n  { id: 3, title: 'Neuromancer', author: { name: 'William Gibson' }, tags: ['fiction', 'cyberpunk'] },\n  { id: 4, title: 'Zen and the Art of Archery', author: { name: 'Eugen Herrigel' }, tags: ['non-fiction', 'zen'] },\n  // ...and more\n]\n\n// We can support nested fields (author.name) and array fields (tags) with a\n// custom `extractField` function:\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'author.name', 'tags'],\n  extractField: (document, fieldName) => {\n    // Access nested fields\n    const value = fieldName.split('.').reduce((doc, key) => doc && doc[key], document)\n    // If field value is an array, join by space\n    return Array.isArray(value) ? value.join(' ') : value\n  }\n})\n```\n\nThe default field extractor can be obtained by calling\n`MiniSearch.getDefault('extractField')`.\n\n### Tokenization\n\nBy default, documents are tokenized by splitting on Unicode space or punctuation\ncharacters. The tokenization logic can be easily changed by passing a custom\ntokenizer function as the `tokenize` option:\n\n```javascript\n// Tokenize splitting by hyphen\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  tokenize: (string, _fieldName) => string.split('-')\n})\n```\n\nUpon search, the same tokenization is used by default, but it is possible to\npass a `tokenize` search option in case a different search-time tokenization is\nnecessary:\n\n```javascript\n// Tokenize splitting by hyphen\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  tokenize: (string) => string.split('-'), // indexing tokenizer\n  searchOptions: {\n    tokenize: (string) => string.split(/[\\s-]+/) // search query tokenizer\n  }\n})\n```\n\nThe default tokenizer can be obtained by calling\n`MiniSearch.getDefault('tokenize')`.\n\n### Term processing\n\nTerms are downcased by default. No stemming is performed, and no stop-word list\nis applied. To customize how the terms are processed upon indexing, for example\nto normalize them, filter them, or to apply stemming, the `processTerm` option\ncan be used. The `processTerm` function should return the processed term as a\nstring, or a falsy value if the term should be discarded:\n\n```javascript\nlet stopWords = new Set(['and', 'or', 'to', 'in', 'a', 'the', /* ...and more */ ])\n\n// Perform custom term processing (here discarding stop words and downcasing)\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  processTerm: (term, _fieldName) =>\n    stopWords.has(term) ? null : term.toLowerCase()\n})\n```\n\nBy default, the same processing is applied to search queries. In order to apply\na different processing to search queries, supply a `processTerm` search option:\n\n```javascript\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  processTerm: (term) =>\n    stopWords.has(term) ? null : term.toLowerCase(), // index term processing\n  searchOptions: {\n    processTerm: (term) => term.toLowerCase() // search query processing\n  }\n})\n```\n\nThe default term processor can be obtained by calling\n`MiniSearch.getDefault('processTerm')`.\n\n### API Documentation\n\nRefer to the [API documentation](https://lucaong.github.io/minisearch/identifiers.html)\nfor details about configuration options and methods.\n\n\n## Browser compatibility\n\n`MiniSearch` natively supports all modern browsers implementing JavaScript\nstandards, but requires a polyfill when used in Internet Explorer, as it makes\nuse functions like `Object.entries`, `Array.includes`, and `Array.from`, which\nare standard but not available on older browsers. The package\n[`core-js`](https://github.com/zloirock/core-js) is one such polyfill that can\nbe used to provide those functions.\n\n## Contributing\n\nContributions to `MiniSearch` are welcome! Please read the [contributions\nguidelines](https://lucaong.github.io/minisearch/manual/CONTRIBUTING.html).\nReading the [design\ndocument](https://lucaong.github.io/minisearch/manual/DESIGN_DOCUMENT.html) is\nalso useful to understand the project goals and the technical implementation.\n",
    "longname": "/Users/luca/Code/minisearch/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"minisearch\",\n  \"version\": \"2.0.6\",\n  \"description\": \"Tiny but powerful full-text search engine for browser and Node\",\n  \"main\": \"dist/minisearch.js\",\n  \"author\": \"Luca Ongaro\",\n  \"homepage\": \"https://lucaong.github.io/minisearch/\",\n  \"bugs\": \"https://github.com/lucaong/minisearch/issues\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/lucaong/minisearch.git\"\n  },\n  \"keywords\": [\n    \"search\",\n    \"full text\",\n    \"fuzzy\",\n    \"prefix\",\n    \"auto suggest\",\n    \"auto complete\",\n    \"index\"\n  ],\n  \"license\": \"MIT\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.0.0\",\n    \"@babel/core\": \"^7.0.1\",\n    \"@babel/node\": \"^7.5.5\",\n    \"@babel/plugin-proposal-object-rest-spread\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.0.0\",\n    \"babel-core\": \"^7.0.0-0\",\n    \"babel-jest\": \"^24.0.0\",\n    \"babel-loader\": \"^8.0.4\",\n    \"benchmark\": \"^2.1.4\",\n    \"core-js\": \"^3.1.4\",\n    \"coveralls\": \"^3.0.2\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"fast-check\": \"^1.5.0\",\n    \"jest\": \"^24.0.0\",\n    \"regenerator-runtime\": \"^0.13.1\",\n    \"snazzy\": \"^8.0.0\",\n    \"standard\": \"^12.0.1\",\n    \"typescript\": \"^3.5.3\",\n    \"webpack\": \"^4.16.5\",\n    \"webpack-cli\": \"^3.1.0\",\n    \"webpack-merge\": \"^4.2.1\"\n  },\n  \"files\": [\n    \"/dist/minisearch.js\",\n    \"/src/**/*\"\n  ],\n  \"jest\": {\n    \"testURL\": \"http://localhost:3000/\",\n    \"setupFilesAfterEnv\": [\n      \"<rootDir>/src/testSetup/jest.js\"\n    ]\n  },\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test-watch\": \"jest --watch\",\n    \"coverage\": \"jest --coverage\",\n    \"benchmark\": \"NODE_ENV=production babel-node --expose-gc benchmarks/index.js\",\n    \"build\": \"webpack --mode=production\",\n    \"build-minified\": \"webpack --mode=production --config=webpack.minified.js\",\n    \"build-docs\": \"esdoc\",\n    \"lint\": \"standard --verbose 'app/**/*.{js,jsx}' | snazzy\",\n    \"lintfix\": \"standard --fix 'app/**/*.{js,jsx}'\",\n    \"prepublishOnly\": \"yarn test && yarn build\"\n  },\n  \"types\": \"./src/index.d.ts\"\n}\n",
    "longname": "/Users/luca/Code/minisearch/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/luca/Code/minisearch/README.md",
    "name": "README.md",
    "content": "# [![MiniSearch](https://lucaong.github.io/minisearch/MiniSearch.svg)](https://lucaong.github.io/minisearch/) MiniSearch\n\n[![Build Status](https://travis-ci.org/lucaong/minisearch.svg?branch=master)](https://travis-ci.org/lucaong/minisearch)\n[![Coverage Status](https://coveralls.io/repos/github/lucaong/minisearch/badge.svg?branch=master)](https://coveralls.io/github/lucaong/minisearch?branch=master)\n[![Minzipped Size](https://img.shields.io/bundlephobia/minzip/minisearch.svg?style=flat)](https://bundlephobia.com/result?p=minisearch)\n[![](https://data.jsdelivr.com/v1/package/npm/minisearch/badge?style=rounded)](https://www.jsdelivr.com/package/npm/minisearch)\n\n`MiniSearch` is a tiny but powerful in-memory fulltext search engine written in\nJavaScript. It is respectful of resources, and it can comfortably run both in\nNode and in the browser.\n\nTry out the [demo application](https://lucaong.github.io/minisearch/examples/).\n\nFind the complete [documentation and API reference\nhere](https://lucaong.github.io/minisearch), and more background about\n`MiniSearch`, including a comparison with other similar libraries, in [this blog\npost](https://lucaongaro.eu/blog/2019/01/30/minisearch-client-side-fulltext-search-engine.html).\n\n\n## Use case\n\n`MiniSearch` addresses use cases where full-text search features are needed\n(e.g. prefix search, fuzzy search, ranking, boosting of fields…), but the data\nto be indexed can fit locally in the process memory. While you won't index the\nwhole Internet with it, there are surprisingly many use cases that are served\nwell by `MiniSearch`. By storing the index in local memory, `MiniSearch` can\nwork offline, and can process queries quickly, without network latency.\n\nA prominent use-case is real time search \"as you type\" in web and mobile\napplications, where keeping the index on the client enables fast and reactive\nUIs, removing the need to make requests to a search server.\n\n\n## Features\n\n  * Memory-efficient index, designed to support memory-constrained use cases\n    like mobile browsers.\n\n  * Exact match, prefix search, fuzzy match, field boosting\n\n  * Auto-suggestion engine, for auto-completion of search queries\n\n  * Documents can be added and removed from the index at any time\n\n  * Zero external dependencies\n\n`MiniSearch` strives to expose a simple API that provides the building blocks to\nbuild custom solutions, while keeping a small and well tested codebase.\n\n\n## Installation\n\nWith `npm`:\n\n```\nnpm install --save minisearch\n```\n\nWith `yarn`:\n\n```\nyarn add minisearch\n```\n\nThen `require` or `import` it in your project.\n\nAlternatively, if you prefer to use a `<script>` tag, you can require MiniSearch\nfrom a CDN:\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/minisearch@2.0.6/dist/minisearch.min.js\"></script>\n```\n\nFinally, if you want to manually build the library, clone the repository and run\n`yarn build` (or `yarn build-minified` for a minified version + source maps).\nThe compiled source will be created in the `dist` folder.\n\n\n## Usage\n\n### Basic usage\n\n```javascript\n// A collection of documents for our examples\nconst documents = [\n  {\n    id: 1,\n    title: 'Moby Dick',\n    text: 'Call me Ishmael. Some years ago...',\n    category: 'fiction'\n  },\n  {\n    id: 2,\n    title: 'Zen and the Art of Motorcycle Maintenance',\n    text: 'I can see by my watch...',\n    category: 'fiction'\n  },\n  {\n    id: 3,\n    title: 'Neuromancer',\n    text: 'The sky above the port was...',\n    category: 'fiction'\n  },\n  {\n    id: 4,\n    title: 'Zen and the Art of Archery',\n    text: 'At first sight it must seem...',\n    category: 'non-fiction'\n  },\n  // ...and more\n]\n\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'], // fields to index for full-text search\n  storeFields: ['title', 'category'] // fields to return with search results\n})\n\n// Index all documents\nminiSearch.addAll(documents)\n\n// Search with default options\nlet results = miniSearch.search('zen art motorcycle')\n// => [\n//   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258, match: { ... } },\n//   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629, match: { ... } }\n// ]\n```\n\n### Search options\n\n`MiniSearch` supports several options for more advanced search behavior:\n\n```javascript\n// Search only specific fields\nminiSearch.search('zen', { fields: ['title'] })\n\n// Boost some fields (here \"title\")\nminiSearch.search('zen', { boost: { title: 2 } })\n\n// Prefix search (so that 'moto' will match 'motorcycle')\nminiSearch.search('moto', { prefix: true })\n\n// Search within a specific category\nminiSearch.search('zen', {\n  filter: (result) => result.category === 'fiction'\n})\n\n// Fuzzy search, in this example, with a max edit distance of 0.2 * term length,\n// rounded to nearest integer. The mispelled 'ismael' will match 'ishmael'.\nminiSearch.search('ismael', { fuzzy: 0.2 })\n\n// You can set the default search options upon initialization\nminiSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  searchOptions: {\n    boost: { title: 2 },\n    fuzzy: 0.2\n  }\n})\nminiSearch.addAll(documents)\n\n// It will now by default perform fuzzy search and boost \"title\":\nminiSearch.search('zen and motorcycles')\n```\n\n### Auto suggestions\n\n`MiniSearch` can suggest search queries given an incomplete query:\n\n```javascript\nminiSearch.autoSuggest('zen ar')\n// => [ { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n//      { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\n```\n\nThe `autoSuggest` method takes the same options as the `search` method, so you\ncan get suggestions for misspelled words using fuzzy search:\n\n```javascript\nminiSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n// => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n```\n\nSuggestions are ranked by the relevance of the documents that would be returned\nby that search.\n\nSometimes, you might need to filter auto suggestions to, say, only a specific\ncategory. You can do so by providing a `filter` option:\n\n```javascript\nminiSearch.autoSuggest('zen ar', {\n  filter: (result) => result.category === 'fiction'\n})\n// => [ { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\n```\n\n### Field extraction\n\nBy default, documents are assumed to be plain key-value objects with field names\nas keys and field values as string values. In order to support custom field\nextraction logic (for example for nested fields, or non-string field values\nneeding processing before tokenization), a custom field extractor function can\nbe passed as the `extractField` option:\n\n```javascript\n// Assuming that our documents look like:\nconst documents = [\n  { id: 1, title: 'Moby Dick', author: { name: 'Herman Melville' }, tags: ['fiction', 'whale'] },\n  { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', author: { name: 'Robert Pirsig' }, tags: ['fiction', 'zen'] },\n  { id: 3, title: 'Neuromancer', author: { name: 'William Gibson' }, tags: ['fiction', 'cyberpunk'] },\n  { id: 4, title: 'Zen and the Art of Archery', author: { name: 'Eugen Herrigel' }, tags: ['non-fiction', 'zen'] },\n  // ...and more\n]\n\n// We can support nested fields (author.name) and array fields (tags) with a\n// custom `extractField` function:\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'author.name', 'tags'],\n  extractField: (document, fieldName) => {\n    // Access nested fields\n    const value = fieldName.split('.').reduce((doc, key) => doc && doc[key], document)\n    // If field value is an array, join by space\n    return Array.isArray(value) ? value.join(' ') : value\n  }\n})\n```\n\nThe default field extractor can be obtained by calling\n`MiniSearch.getDefault('extractField')`.\n\n### Tokenization\n\nBy default, documents are tokenized by splitting on Unicode space or punctuation\ncharacters. The tokenization logic can be easily changed by passing a custom\ntokenizer function as the `tokenize` option:\n\n```javascript\n// Tokenize splitting by hyphen\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  tokenize: (string, _fieldName) => string.split('-')\n})\n```\n\nUpon search, the same tokenization is used by default, but it is possible to\npass a `tokenize` search option in case a different search-time tokenization is\nnecessary:\n\n```javascript\n// Tokenize splitting by hyphen\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  tokenize: (string) => string.split('-'), // indexing tokenizer\n  searchOptions: {\n    tokenize: (string) => string.split(/[\\s-]+/) // search query tokenizer\n  }\n})\n```\n\nThe default tokenizer can be obtained by calling\n`MiniSearch.getDefault('tokenize')`.\n\n### Term processing\n\nTerms are downcased by default. No stemming is performed, and no stop-word list\nis applied. To customize how the terms are processed upon indexing, for example\nto normalize them, filter them, or to apply stemming, the `processTerm` option\ncan be used. The `processTerm` function should return the processed term as a\nstring, or a falsy value if the term should be discarded:\n\n```javascript\nlet stopWords = new Set(['and', 'or', 'to', 'in', 'a', 'the', /* ...and more */ ])\n\n// Perform custom term processing (here discarding stop words and downcasing)\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  processTerm: (term, _fieldName) =>\n    stopWords.has(term) ? null : term.toLowerCase()\n})\n```\n\nBy default, the same processing is applied to search queries. In order to apply\na different processing to search queries, supply a `processTerm` search option:\n\n```javascript\nlet miniSearch = new MiniSearch({\n  fields: ['title', 'text'],\n  processTerm: (term) =>\n    stopWords.has(term) ? null : term.toLowerCase(), // index term processing\n  searchOptions: {\n    processTerm: (term) => term.toLowerCase() // search query processing\n  }\n})\n```\n\nThe default term processor can be obtained by calling\n`MiniSearch.getDefault('processTerm')`.\n\n### API Documentation\n\nRefer to the [API documentation](https://lucaong.github.io/minisearch/identifiers.html)\nfor details about configuration options and methods.\n\n\n## Browser compatibility\n\n`MiniSearch` natively supports all modern browsers implementing JavaScript\nstandards, but requires a polyfill when used in Internet Explorer, as it makes\nuse functions like `Object.entries`, `Array.includes`, and `Array.from`, which\nare standard but not available on older browsers. The package\n[`core-js`](https://github.com/zloirock/core-js) is one such polyfill that can\nbe used to provide those functions.\n\n## Contributing\n\nContributions to `MiniSearch` are welcome! Please read the [contributions\nguidelines](https://lucaong.github.io/minisearch/manual/CONTRIBUTING.html).\nReading the [design\ndocument](https://lucaong.github.io/minisearch/manual/DESIGN_DOCUMENT.html) is\nalso useful to understand the project goals and the technical implementation.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/luca/Code/minisearch/CONTRIBUTING.md",
    "name": "CONTRIBUTING.md",
    "content": "# Contributing\n\nContributions to `MiniSearch` are welcome :) Just follow the guidelines below.\n\n## Bugs and feature requests\n\nIf you have an idea for a feature, or spotted a bug, please [open an\nissue on GitHub](https://github.com/lucaong/minisearch/issues).\n\n  - Check if your issue was already reported. In that case, better\n    to comment on the existing issue rather than open a duplicate one.\n\n  - When reporting a bug, whenever possible, provide some example code to\n    reproduce the bug: that will make the process of fixing it much faster.\n\n  - Remember this is an open-source project. Your feature requests will be\n    discussed and taken into consideration, but please do not take it\n    personally if the feature does not get implemented. This project uses a\n    permissive license, so pull requests are welcome and forks are permitted.\n\n  - Always be respectful of others when discussing issues. The project\n    maintainer has the right and responsibility to remove or close discussions\n    where the tone or language is derogatory, harassing, or offensive toward\n    others. Keep the [Code of\n    Conduct](https://lucaong.github.io/minisearch/manual/CODE_OF_CONDUCT.html)\n    in mind.\n\n## Pull requests\n\nThinking about sending a pull request? That is great :) Here is how you can\nsetup your development environment:\n\n  1. Clone the [repository](https://github.com/lucaong/minisearch)\n\n  2. Install the development dependencies with `yarn install`\n\n  3. Run the tests with `yarn test`. You can also automatically trigger a run of\n     relevant tests for the code that you change by running `yarn test-watch`\n\n  4. If you are working on optimising the performance, you can run the\n     performance benchmarks with `yarn benchmark`\n\n  5. If you are improving the documentation, you can build the docs with `yarn\n     build-docs`\n\nIn order to understand implementation details and design goals, read the [design\ndocument](https://lucaong.github.io/minisearch/manual/DESIGN_DOCUMENT.html).\n\nAlso, please follow these guidelines:\n\n  - Add tests for your code. This ensures that your feature won't be broken by\n    further code changes. If you are not sure how to test, feel free to send the\n    pull request and ask for advices in the comment.\n\n  - Don't change the version number. That will be done by the mainteiner upon\n    releasing a new version.\n\n  - Make sure that the full test suite passes before sending the pull request.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/luca/Code/minisearch/CODE_OF_CONDUCT.md",
    "name": "CODE_OF_CONDUCT.md",
    "content": "# Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project maintainer at `mail[AT]lucaongaro.eu`. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/luca/Code/minisearch/DESIGN_DOCUMENT.md",
    "name": "DESIGN_DOCUMENT.md",
    "content": "# Design Document\n\nThis design document has the aim to explain the details of `MiniSearch`\ndesign and implementation to library developers that intend to contribute to\nthis project, or that are simply curious about the internals.\n\n**Latest update: Feb. 11, 2019**\n\n## Goals (and non-goals)\n\n`MiniSearch` is aimed at providing rich full-text search functionalities in a\nlocal setup (e.g. client side, in the browser). It is therefore optimized for:\n\n  1. Small memory footprint of the index data structure\n  2. Fast indexing of documents\n  3. Versatile and performant search features, to the extent possible while\n     meeting goals 1 and 2\n  4. Small and simple API surface, on top of which more specific solutions can\n     be built by application developers\n  5. Possibility to add and remove documents from the index at any time\n\n`MiniSearch` is therefore NOT directly aimed at offering:\n\n  - A solution for use cases requiring large index data structure size\n  - Distributed setup where the index resides on multiple nodes and need to be\n    kept in sync\n  - Turn-key opinionated solutions (e.g. supporting multiple locales):\n    `MiniSearch` _enables_ developer to build these on top of the core API, but\n    does not provide it out of the box.\n\nFor these points listed as non-goals, other solutions exist that should be\npreferred to `MiniSearch`. Adapting `MiniSearch` to support those goals would in\nfact necessarily go against the primary project goals.\n\n\n## Technical design\n\n`MiniSearch` is composed of two layers:\n\n  1. A compact and versatile data structure for indexing terms, providing\n     prefix and fuzzy lookup\n  2. An API layer on top of this data structure, providing the search\n    features\n\nHere follows a description of these two layers.\n\n### Index data structure\n\nThe data structure chosen for the index is a [radix\ntree](https://en.wikipedia.org/wiki/Radix_tree), which is a prefix tree where\nnodes with no siblings are merged with the parent node. The reason for choosing\nthis data structure follows from the project goals:\n\n  - The radix tree minimizes the memory footprint of the index, because common\n    prefixes are stored only once, and nodes are compressed into a single\n    multi-character node whenever possible.\n  - Radix trees offer fast key lookup, with performance proportional to the key\n    length, and fast lookup of subtrees sharing the same key prefix. These\n    properties make it possible to offer exact match and prefix search.\n  - On top of a radix tree it is possible to implement lookup of keys that are\n    within a certain maximum edit distance from a given key. This search rapidly\n    becomes complex as the maximum distance grows, but for practical search\n    use-cases the maximum distance is small enough for this algorithm to be\n    performant. Other more performant solutions for fuzzy search would require\n    more space (e.g. n-gram indexes).\n\nThe class implementing the radix tree is called `SearchableMap`, because it\nimplements the standard JavaScript [`Map`\ninterface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map),\nadding on top of it some key lookup methods:\n\n  - `SearchableMap.prototype.atPrefix(prefix)`, returning another\n    `SearchableMap` representing a mutable view of the original one, containing\n    only entries where the keys share the given prefix.\n  - `SearchableMap.prototype.fuzzyGet(searchKey, maxEditDistance)`, returning\n    all the entries where the key is within the given edit (Levenshtein)\n    distance from `searchKey`.\n\nAs a trade-off for offering these additional features, `SearchableMap` is\nrestricted to use only string keys.\n\nThe `SearchableMap` data type is part of the public API of `MiniSearch`, exposed\nas `MiniSearch.SearchableMap`. Its usefulness is in fact not limited to\nproviding a data structure for the inverted index, and developers can use it as\na building block for other solutions. When modifying this class, one should\nthink about it in terms of a generic data structure, that could in principle be\nreleased as a separate library.\n\n### Fuzzy search algorithm\n\nThe algorithm used to provide fuzzy search of keys within a maximum [Levenshtein\ndistance](https://en.wikipedia.org/wiki/Levenshtein_distance) from a given term\nis the following:\n\n  - The search starts with a budget of edit distance, initially equal to the\n    given maximum distance.\n  - The radix tree is traversed, starting from the root, visiting each path and\n    propagating the remaining budget along each path, but quitting any search\n    path along which the budget is exhausted.\n  - For each visited node in the radix tree, the string contained in the node is\n    traversed character by character using cursors that are kept on a stack.\n  - Each cursor has: a pointer to a position in the node string; a pointer to a\n    corresponding position in the search string; the type of the last edit,\n    either `deletion`, or `insertion`, or `change`, or `none`; a budget of\n    \"available edits\". This budget is decremented whenever an edit is required.\n    The budget is passed from parent to children cursors.\n  - The algorithm pulls cursors from the stack, and compares the pointed\n    character in the node string with the pointed character in the search\n    string:\n    * if they are the same, one single child cursor is created, advancing both\n      pointers of 1 position. No edit was necessary, so the last edit type is\n      `none`.\n    * if they are not the same, and the remaining budget is higher than zero, up\n      to three children cursors are created: one corresponding to a character\n      `change`, where both pointers are incremented by 1; one corresponding to a\n      `deletion`, where only the search string pointer is incremented; one\n      corresponding to an `insertion`, where only the node string pointer is\n      incremented. Each of the children cursors have a budget that is one less\n      the parent budget.\n    * Some special cases are considered to avoid creating unnecessary cursors. A\n      sequence of adjacent `deletion`-`insertion`, or `insertion`-`deletion`,\n      would have the same effect of a change, but would consume more budget:\n      therefore, a delete cursor is never created after a insertion cursor, and\n      vice-versa. Similarily, adjacent `change`-`deletion` and\n      `deletion`-`change`, or `change`-`insertion` and `insertion`-`change`, are\n      equivalent. Therefore, only one of these cases is generated, by never\n      producing a change cursor after a deletion or insertion one.\n  - Whenever the algorithm finds a leaf node, it reports it as a result.\n\nNote that this algorithm can get complex if the maximum edit distance is large,\nas many paths would be followed. The reason why this algorithm is employed is a\ntrade-off:\n\n  - For full-text search purposes, the maximum edit distance is small, so the\n    algorithm is performant enough\n  - The alternatives (e.g. trigram indexes), would require much more space\n  - As `MiniSearch` is optimized for local and possibly memory-constrained\n    setup, higher computation complexity is traded in exchange for smaller space\n    requirement for the index.\n\n### Search API layer\n\nThe search API layer offers a small and simple API surface for application\ndevelopers. It does not assume that a specific locale is used in the indexed\ndocuments, therefore no stemming nor stop-word filtering is performed, but\ninstead offers easy options for developers to provide their own implementation.\nThis heuristic will be followed in future development too: rather than providing\nan opinionated solution, the project will offer simple building blocks for\napplication developers to implement their own solutions.\n\nThe inverted index is implemented with `SearchableMap`, and posting lists are\nstored as values in the Map. This way, the same data structure provides both the\ninverted index and the set of indexed terms. Different document fields are\nindexed within the same index, to further save space. The index is therefore\nstructured as following:\n\n```\nterm -> field -> { document frequency, posting list }\n```\n\nWhen performing a search, the entries corresponding to the search term are\nlooked up in the index (optionally searching the index with prefix or fuzzy\nsearch), then the documents are scored with a variant of\n[Tf-Idf](https://en.wikipedia.org/wiki/Tf–idf), and finally results for\ndifferent search terms are merged with the given combinator function (by default\n`OR`, but `AND` can be specified).\n\nAs the document IDs necessarily occur many times in the posting list, as a space\noptimization they are substituted by short generated IDs. An index of short ID\nto original ID is maintained alongside the search index, to reconstruct the\noriginal IDs. A similar optimization is applied to the field names.\n",
    "static": true,
    "access": "public"
  }
]