<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">Home | MiniSearch</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Tiny but powerful full-text search"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="MiniSearch"><meta property="twitter:description" content="Tiny but powerful full-text search"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/lucaong/minisearch"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MiniSearch.js~MiniSearch.html">MiniSearch</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#searchablemap">SearchableMap</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SearchableMap/SearchableMap.js~SearchableMap.html">SearchableMap</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="-a-href--https---lucaong-github-io-minisearch----img-src--https---lucaong-github-io-minisearch-minisearch-svg--alt--minisearch----a--minisearch"><a href="https://lucaong.github.io/minisearch/"><img src="https://lucaong.github.io/minisearch/MiniSearch.svg" alt="MiniSearch"></a> MiniSearch</h1><p><a href="https://travis-ci.org/lucaong/minisearch"><img src="https://travis-ci.org/lucaong/minisearch.svg?branch=master" alt="Build Status"></a>
<a href="https://coveralls.io/github/lucaong/minisearch?branch=master"><img src="https://coveralls.io/repos/github/lucaong/minisearch/badge.svg?branch=master" alt="Coverage Status"></a>
<a href="https://bundlephobia.com/result?p=minisearch"><img src="https://badgen.net/bundlephobia/minzip/minisearch" alt="Minzipped Size"></a>
<a href="https://www.jsdelivr.com/package/npm/minisearch"><img src="https://data.jsdelivr.com/v1/package/npm/minisearch/badge?style=rounded" alt></a></p>
<p><code>MiniSearch</code> is a tiny but powerful in-memory fulltext search engine written in
JavaScript. It is respectful of resources, and it can comfortably run both in
Node and in the browser.</p>
<p>Try out the <a href="https://lucaong.github.io/minisearch/examples/">demo application</a>.</p>
<p>Find the complete <a href="https://lucaong.github.io/minisearch">documentation and API reference
here</a>, and more background about
<code>MiniSearch</code>, including a comparison with other similar libraries, in <a href="https://lucaongaro.eu/blog/2019/01/30/minisearch-client-side-fulltext-search-engine.html">this blog
post</a>.</p>
<h2 id="use-case">Use case</h2><p><code>MiniSearch</code> addresses use cases where full-text search features are needed
(e.g. prefix search, fuzzy search, ranking, boosting of fields&#x2026;), but the data
to be indexed can fit locally in the process memory. While you won&apos;t index the
whole Internet with it, there are surprisingly many use cases that are served
well by <code>MiniSearch</code>. By storing the index in local memory, <code>MiniSearch</code> can
work offline, and can process queries quickly, without network latency.</p>
<p>A prominent use-case is real time search &quot;as you type&quot; in web and mobile
applications, where keeping the index on the client enables fast and reactive
UIs, removing the need to make requests to a search server.</p>
<h2 id="features">Features</h2><ul>
<li><p>Memory-efficient index, designed to support memory-constrained use cases
like mobile browsers.</p>
</li>
<li><p>Exact match, prefix search, fuzzy match, field boosting</p>
</li>
<li><p>Auto-suggestion engine, for auto-completion of search queries</p>
</li>
<li><p>Documents can be added and removed from the index at any time</p>
</li>
<li><p>Zero external dependencies</p>
</li>
</ul>
<p><code>MiniSearch</code> strives to expose a simple API that provides the building blocks to
build custom solutions, while keeping a small and well tested codebase.</p>
<h2 id="installation">Installation</h2><p>With <code>npm</code>:</p>
<pre><code><code class="source-code prettyprint">npm install --save minisearch</code>
</code></pre><p>With <code>yarn</code>:</p>
<pre><code><code class="source-code prettyprint">yarn add minisearch</code>
</code></pre><p>Then <code>require</code> or <code>import</code> it in your project.</p>
<p>Alternatively, if you prefer to use a <code>&lt;script&gt;</code> tag, you can require MiniSearch
from a CDN:</p>
<pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/minisearch@2.2.2/dist/umd/index.min.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>Finally, if you want to manually build the library, clone the repository and run
<code>yarn build</code> (or <code>yarn build-minified</code> for a minified version + source maps).
The compiled source will be created in the <code>dist</code> folder (UMD, ES6 and ES2015
module versions are provided).</p>
<h2 id="usage">Usage</h2><h3 id="basic-usage">Basic usage</h3><pre><code class="lang-javascript"><code class="source-code prettyprint">// A collection of documents for our examples
const documents = [
  {
    id: 1,
    title: &apos;Moby Dick&apos;,
    text: &apos;Call me Ishmael. Some years ago...&apos;,
    category: &apos;fiction&apos;
  },
  {
    id: 2,
    title: &apos;Zen and the Art of Motorcycle Maintenance&apos;,
    text: &apos;I can see by my watch...&apos;,
    category: &apos;fiction&apos;
  },
  {
    id: 3,
    title: &apos;Neuromancer&apos;,
    text: &apos;The sky above the port was...&apos;,
    category: &apos;fiction&apos;
  },
  {
    id: 4,
    title: &apos;Zen and the Art of Archery&apos;,
    text: &apos;At first sight it must seem...&apos;,
    category: &apos;non-fiction&apos;
  },
  // ...and more
]

let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;], // fields to index for full-text search
  storeFields: [&apos;title&apos;, &apos;category&apos;] // fields to return with search results
})

// Index all documents
miniSearch.addAll(documents)

// Search with default options
let results = miniSearch.search(&apos;zen art motorcycle&apos;)
// =&gt; [
//   { id: 2, title: &apos;Zen and the Art of Motorcycle Maintenance&apos;, category: &apos;fiction&apos;, score: 2.77258, match: { ... } },
//   { id: 4, title: &apos;Zen and the Art of Archery&apos;, category: &apos;non-fiction&apos;, score: 1.38629, match: { ... } }
// ]</code>
</code></pre>
<h3 id="search-options">Search options</h3><p><code>MiniSearch</code> supports several options for more advanced search behavior:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">// Search only specific fields
miniSearch.search(&apos;zen&apos;, { fields: [&apos;title&apos;] })

// Boost some fields (here &quot;title&quot;)
miniSearch.search(&apos;zen&apos;, { boost: { title: 2 } })

// Prefix search (so that &apos;moto&apos; will match &apos;motorcycle&apos;)
miniSearch.search(&apos;moto&apos;, { prefix: true })

// Search within a specific category
miniSearch.search(&apos;zen&apos;, {
  filter: (result) =&gt; result.category === &apos;fiction&apos;
})

// Fuzzy search, in this example, with a max edit distance of 0.2 * term length,
// rounded to nearest integer. The mispelled &apos;ismael&apos; will match &apos;ishmael&apos;.
miniSearch.search(&apos;ismael&apos;, { fuzzy: 0.2 })

// You can set the default search options upon initialization
miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;],
  searchOptions: {
    boost: { title: 2 },
    fuzzy: 0.2
  }
})
miniSearch.addAll(documents)

// It will now by default perform fuzzy search and boost &quot;title&quot;:
miniSearch.search(&apos;zen and motorcycles&apos;)</code>
</code></pre>
<h3 id="auto-suggestions">Auto suggestions</h3><p><code>MiniSearch</code> can suggest search queries given an incomplete query:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">miniSearch.autoSuggest(&apos;zen ar&apos;)
// =&gt; [ { suggestion: &apos;zen archery art&apos;, terms: [ &apos;zen&apos;, &apos;archery&apos;, &apos;art&apos; ], score: 1.73332 },
//      { suggestion: &apos;zen art&apos;, terms: [ &apos;zen&apos;, &apos;art&apos; ], score: 1.21313 } ]</code>
</code></pre>
<p>The <code>autoSuggest</code> method takes the same options as the <code>search</code> method, so you
can get suggestions for misspelled words using fuzzy search:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">miniSearch.autoSuggest(&apos;neromancer&apos;, { fuzzy: 0.2 })
// =&gt; [ { suggestion: &apos;neuromancer&apos;, terms: [ &apos;neuromancer&apos; ], score: 1.03998 } ]</code>
</code></pre>
<p>Suggestions are ranked by the relevance of the documents that would be returned
by that search.</p>
<p>Sometimes, you might need to filter auto suggestions to, say, only a specific
category. You can do so by providing a <code>filter</code> option:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">miniSearch.autoSuggest(&apos;zen ar&apos;, {
  filter: (result) =&gt; result.category === &apos;fiction&apos;
})
// =&gt; [ { suggestion: &apos;zen art&apos;, terms: [ &apos;zen&apos;, &apos;art&apos; ], score: 1.21313 } ]</code>
</code></pre>
<h3 id="field-extraction">Field extraction</h3><p>By default, documents are assumed to be plain key-value objects with field names
as keys and field values as string values. In order to support custom field
extraction logic (for example for nested fields, or non-string field values
needing processing before tokenization), a custom field extractor function can
be passed as the <code>extractField</code> option:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">// Assuming that our documents look like:
const documents = [
  { id: 1, title: &apos;Moby Dick&apos;, author: { name: &apos;Herman Melville&apos; }, tags: [&apos;fiction&apos;, &apos;whale&apos;] },
  { id: 2, title: &apos;Zen and the Art of Motorcycle Maintenance&apos;, author: { name: &apos;Robert Pirsig&apos; }, tags: [&apos;fiction&apos;, &apos;zen&apos;] },
  { id: 3, title: &apos;Neuromancer&apos;, author: { name: &apos;William Gibson&apos; }, tags: [&apos;fiction&apos;, &apos;cyberpunk&apos;] },
  { id: 4, title: &apos;Zen and the Art of Archery&apos;, author: { name: &apos;Eugen Herrigel&apos; }, tags: [&apos;non-fiction&apos;, &apos;zen&apos;] },
  // ...and more
]

// We can support nested fields (author.name) and array fields (tags) with a
// custom `extractField` function:
let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;author.name&apos;, &apos;tags&apos;],
  extractField: (document, fieldName) =&gt; {
    // Access nested fields
    const value = fieldName.split(&apos;.&apos;).reduce((doc, key) =&gt; doc &amp;&amp; doc[key], document)
    // If field value is an array, join by space
    return Array.isArray(value) ? value.join(&apos; &apos;) : value
  }
})</code>
</code></pre>
<p>The default field extractor can be obtained by calling
<code>MiniSearch.getDefault(&apos;extractField&apos;)</code>.</p>
<h3 id="tokenization">Tokenization</h3><p>By default, documents are tokenized by splitting on Unicode space or punctuation
characters. The tokenization logic can be easily changed by passing a custom
tokenizer function as the <code>tokenize</code> option:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">// Tokenize splitting by hyphen
let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;],
  tokenize: (string, _fieldName) =&gt; string.split(&apos;-&apos;)
})</code>
</code></pre>
<p>Upon search, the same tokenization is used by default, but it is possible to
pass a <code>tokenize</code> search option in case a different search-time tokenization is
necessary:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">// Tokenize splitting by hyphen
let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;],
  tokenize: (string) =&gt; string.split(&apos;-&apos;), // indexing tokenizer
  searchOptions: {
    tokenize: (string) =&gt; string.split(/[\s-]+/) // search query tokenizer
  }
})</code>
</code></pre>
<p>The default tokenizer can be obtained by calling
<code>MiniSearch.getDefault(&apos;tokenize&apos;)</code>.</p>
<h3 id="term-processing">Term processing</h3><p>Terms are downcased by default. No stemming is performed, and no stop-word list
is applied. To customize how the terms are processed upon indexing, for example
to normalize them, filter them, or to apply stemming, the <code>processTerm</code> option
can be used. The <code>processTerm</code> function should return the processed term as a
string, or a falsy value if the term should be discarded:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">let stopWords = new Set([&apos;and&apos;, &apos;or&apos;, &apos;to&apos;, &apos;in&apos;, &apos;a&apos;, &apos;the&apos;, /* ...and more */ ])

// Perform custom term processing (here discarding stop words and downcasing)
let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;],
  processTerm: (term, _fieldName) =&gt;
    stopWords.has(term) ? null : term.toLowerCase()
})</code>
</code></pre>
<p>By default, the same processing is applied to search queries. In order to apply
a different processing to search queries, supply a <code>processTerm</code> search option:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">let miniSearch = new MiniSearch({
  fields: [&apos;title&apos;, &apos;text&apos;],
  processTerm: (term) =&gt;
    stopWords.has(term) ? null : term.toLowerCase(), // index term processing
  searchOptions: {
    processTerm: (term) =&gt; term.toLowerCase() // search query processing
  }
})</code>
</code></pre>
<p>The default term processor can be obtained by calling
<code>MiniSearch.getDefault(&apos;processTerm&apos;)</code>.</p>
<h3 id="api-documentation">API Documentation</h3><p>Refer to the <a href="https://lucaong.github.io/minisearch/identifiers.html">API documentation</a>
for details about configuration options and methods.</p>
<h2 id="browser-compatibility">Browser compatibility</h2><p><code>MiniSearch</code> natively supports all modern browsers implementing JavaScript
standards, but requires a polyfill when used in Internet Explorer, as it makes
use functions like <code>Object.entries</code>, <code>Array.includes</code>, and <code>Array.from</code>, which
are standard but not available on older browsers. The package
<a href="https://github.com/zloirock/core-js"><code>core-js</code></a> is one such polyfill that can
be used to provide those functions.</p>
<h2 id="contributing">Contributing</h2><p>Contributions to <code>MiniSearch</code> are welcome! Please read the <a href="https://lucaong.github.io/minisearch/manual/CONTRIBUTING.html">contributions
guidelines</a>.
Reading the <a href="https://lucaong.github.io/minisearch/manual/DESIGN_DOCUMENT.html">design
document</a> is
also useful to understand the project goals and the technical implementation.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
